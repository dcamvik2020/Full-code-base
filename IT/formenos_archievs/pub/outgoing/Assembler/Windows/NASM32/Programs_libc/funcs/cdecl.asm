section .data use32 class=DATA
a	dd 3
b	dd 4

section .text use32 class=CODE

; parameters: a, b, c, d on stack (R->L)
; returns: eax
my_func:
	; пролог функции - можно заменить на команду "enter M, 0", где M - суммарный размер всех локальных переменных
	push ebp
	mov ebp, esp
	; выделяем в стеке память под все локальные переменные этой функции
	sub esp, 8		; 4*m, где m - число int'овских переменных (в данном случае i и j)
	; теперь [ebp-4] - это int i, [ebp-8] - это int j, хотя можно было и наоборот

	; тело функции, здесь делаем что-то полезное
	mov eax, [ebp+8]	; обращаемся к первому параметру функции
	add eax, [ebp+12]	; ко второму
	add eax, [ebp+16]	; к третьему
	add eax, [ebp+20]	; к четвёртому
	mov [ebp-4], eax	; сохраняем это зачем-нибудь в 1-ю локальную переменную (i)...


	; эпилог функции - можно заменить на команду leave
	mov esp, ebp
	pop ebp

	ret			; выход из функции

main:
	; пролог и эпилог функции main опускаем, хотя они тоже могут быть
	enter 0, 0
	mov eax, 1		; инициализация

	; заносим параметры в стек в обратном порядке
	push dword [b]		; четвёртый параметр
	push dword [a]		; третий параметр
	push 2			; второй параметр
	push eax		; первый параметр
	call my_func		; вызов функции
	; очищаем стек
	add esp, 16		; 4*n, где n - число параметров функции
	; анализируем возвращаемое значение функции...
;	cmp eax, 10
;	jcc ...

	; выход из функции main
	mov eax, 0
	leave
	ret

global _start
_start:
	call main	; а это для самопроверки, чтобы убедиться, что мы стек не нарушили
	mov eax, 0
	ret
