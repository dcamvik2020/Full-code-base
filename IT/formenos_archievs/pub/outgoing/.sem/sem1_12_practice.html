<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Семинар 12: Интерфейсы, сортировки и другие вкусности - Практика</title>
</head>
<body>
<div style="white-space: pre-wrap;">
<ol>
<li>Для начала флешбэки с прошлых семинаров:
<ol>
<li>Я обещал написать, <a href="sem1_12_valasan.html">как самостоятельно <b>собрать и запустить свою программу с инструментами поиска ошибок (под Valgrind'ом ИЛИ AddressSanitizer'ом)</b></a>, аналогично тому, как это делается в EJudge.
</li>
<li>Как и обещал, задачу qsort_points я выложил себе на сервер (соответственно, она сгорела) в двух вариантах:
<ul>
<li><a href="../C1/qsort_points_v1.c" target="_blank">qsort_points_v1</a> - с подсчётом квадрата радиус-вектора при каждом сравнении точек (проигрывает по времени и выигрывает по памяти) и
</li>
<li><a href="../C1/qsort_points_v2.c" target="_blank">qsort_points_v2</a> - с сохранением квадрата радиус-вектора в структуру (выигрывает по времени, но проигрывает по памяти).
</li></ul></li>
<li><a href="../C1/files.c" target="_blank">files</a> - ещё я недавно набросал маленький шаблон работы с файлами в структурированном виде - программу, считывающую два числа из файла и выводящую результат в файл. Можете использовать как заготовку.
</li>
<li>Затем мы разобрали многострадальный qsort_file. Предлагаю свои две версии:
<ul>
<li><a href="../C1/qsortfile.c" target="_blank">qsortfile</a> - стандартный, быстрый и экономичный способ с помощью динамического двумерного массива <tt>char</tt>'ов (или, что то же самое, конструкции "массива указателей" на <tt>char</tt> (на самом деле, цепочки <tt>char</tt>'ов) - строки различной длины, разбросанные по памяти как попало) и
</li>
<li><a href="../C1/qsortfile0.c" target="_blank">qsortfile0</a> - более изощрённый способ (который в контесте не проходит некоторые тесты по Memory Limit'у) - с помощью выделения памяти целиком сразу под весь массив строк, одним непрерывным куском (массив ровно прямоугольный). Пример использования конструкции "указатель на массивы", а также <tt>qsort</tt> без имплементации отдельной функции сравнения.
</li></ul>
И там и там <tt>text[i]</tt> - это строки, но устроенные по-разному.
В этих вариантах, вдобавок, имена файлов передаются через параметры командной строки (а при отсутствии оных запрашиваются с консоли).
Прикрутите сюда ещё рекурсивную обработку всех вложенных файлов и папок - и получите яркий пример индивидуальной задачи на зачёте (половина задач, наверное, будет решаться по этой схеме).
Теперь задача qsort_file закрывается для сдачи, решайте вместо неё sortfile, которая стоит 3 балла.
</li>
<li>Закончили развивать тему про <b>списки</b>:
<a href="../C1/structures/liststd.cpp" target="_blank">liststd</a> - пример работы со стандартными списками библиотеки STL с помощью <b>итераторов</b> (иначе там и нельзя). Те, кто знает C++, могут посмотреть. Остальные, если не боятся, тоже могут.
</li></ol></li>
<li>Продолжили флешфорвардом - небольшим оффтопиком:
<a href="../C1/structures/treesort_win.c" target="_blank">treesort_win</a> (для Windows) и <a href="../C1/structures/treesort_lin.c" target="_blank">treesort_lin</a> (для Linux) - моя довольно полезная программа, помогающая ответить на вопрос, с каких файлов и папок надо начать удалять, чтобы освободить место на диске. Она сканирует рекурсивно все вложенные файлы и папки в данном каталоге, составляет из них дерево, затем сортирует это дерево (в каждой папке она располагает её дочерние элементы по убыванию размера; для папок тоже подсчитывается их размер) и распечатывает это дерево с помощью обхода в глубину.
Эта программа для того, чтобы вы научились разбираться в чужом коде, а также образец Code Style и наличия комментариев.
Деревья мы будем проходить в следующий раз, но будет здорово, если вы уже сейчас начнёте к этому готовиться.
Посмотрите исходный код этой программы, заметьте несколько моментов, которые могут вам пригодиться в дальнейшем:
<ul>
<li>Организация дерева не сложнее, чем организация двусвязного списка, а работа с ним - по сути, работа с односвязными списками.
</li>
<li>Для печати красивого и стройного дерева используется вся мощь спецификаторов форматного вывода функций <tt><b>sprintf</b>()</tt>, <tt><b>printf</b>()</tt>.
</li>
<li><tt><b>tree_print</b>()</tt> и <tt><b>tree_free</b>()</tt> - пример обхода дерева в глубину с помощью рекурсии.
</li>
<li>Найдите в коде уже известный нам алгоритм сортировки слиянием. С незначительными модификациями может быть использован для сортировки списка в задаче sortfile.
</li>
<li><tt><b>scan_dir</b>()</tt> - сканирование директории и получение вложенных файлов и папок.
В Windows и Linux сканирование выполняется немного разными функциями, поэтому и версии программы разные. Об этом тоже поговорим на последнем семинаре.
</li>
<li>В <tt><b>main</b>()</tt> используется мой любимый приём: если путь сканируемой директории задан через параметр командной строки, то используется именно он, иначе программа запрашивает путь с экрана. Пригодится вам для индивидуальных задач на зачёте.
</li></ul>
Как пользоваться этой программой:
<ul>
<li>Либо запускаем из среды разработки, тогда директория запрашивается у пользователя в интерактивном режиме.
</li>
<li>Либо запускаем скомпилированную программу из командной строки. Тогда у нас появляется бонусная возможность - перенаправить весь вывод в файл, особенно если он велик. Делается это с помощью оператора <tt>&gt;</tt>
<tt>treesort D:\Temp &gt; list.txt</tt>
</li></ul>
Если найдёте ошибки в этой программе, буду благодарен, если вы об этом мне сообщите.
</li>
<li>Ну и наконец, тема этого семинара - <a href="../C1/sort" target="_blank"><b>сортировки</b></a>:
<ul>
<li><a href="../C1/sort/selection.c" target="_blank">selection</a> - выбором, O(n<sup>2</sup>);
</li>
<li><a href="../C1/sort/bubble.c" target="_blank">bubble</a> - Пузырёк, O(n<sup>2</sup>);
</li>
<li><a href="../C1/sort/bubble2.c" target="_blank">bubble2</a> - усовершенствованный Пузырёк, O(n<sup>2</sup>) в худшем случае;
</li>
<li><a href="../C1/sort/insertion.c" target="_blank">insertion</a> - вставками, O(n<sup>2</sup>);
</li>
<li><a href="../C1/sort/quicksort.c" target="_blank">quicksort</a> - быстрая сортировка Хо(а)ра, O(n*log(n)) в среднем (но O(n<sup>2</sup>) в самом худшем случае); <i>неустойчивая</i>;
</li>
<li><a href="../C1/sort/merge.c" target="_blank">merge</a> - слиянием, O(n*log(n)), но требует доп.памяти для массивов; как ни странно, но для списков не требует;
</li>
<li><a href="../C1/sort/sorts.c" target="_blank">sorts</a> - все эти сортировки в одном модуле.
</li></ul></li></ol>
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
