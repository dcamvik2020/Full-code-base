<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Урок 9: Читаем файлы, как книгу</title>
</head>
<body>
<div style="white-space: pre-wrap;">
Продолжаем серию <strike>статей</strike> заметок на тему "Как в Си сделать так, чтобы было как у людей?"
<ol>
<li>На прошлых уроках Продвинутой Магии мы с вами научились средствами обычного Си <a href="sem2_08_adv_magic.html">разбивать непрерывный входной поток байтов на строки</a>, а также <a href="sem2_07_adv_magic.html">читать строки, потенциально неограниченные по длине</a>, которая к тому же ещё и заранее неизвестна. Продолжаем повышать Уровень™. И сегодня я покажу вам, как за один проход прочитать целиком текстовый файл, само число строк которого неизвестно, и сохранить всё это в массив (а не список!), при этом потратив минимум памяти (привет, задача <b><u>sortfile</u></b>!).
Идея, в сущности, та же, что и при чтении длинных строк в <a href="../C2/adv/read_string.c" target="_blank">read_string.c</a>, которую я вам когда-то высылал. А именно:
<ol>
<li>Держим динамический массив указателей на строку (<tt>char **Data = NULL</tt>), его текущий размер (<tt>int num_lines</tt>) и индекс (<tt>int idx = 0</tt>), который указывает, насколько наш массив заполнен в данный момент.
</li>
<li>При переполнении массива (<tt>if (idx &gt;= num_lines)</tt>) перераспределяем под него память - увеличиваем размер вдвое (<tt>num_lines *= 2</tt>) и динамически расширяем массив без потери содержимого (<tt>Data = (char **) realloc(Data, num_lines * sizeof(char *))</tt>).
</li>
<li>Всё это инициализируем таким образом, чтобы на первой итерации начальный кусок памяти выделился всё тем же <tt><b>realloc</b></tt>'ом. Не надо <strike>грязи</strike> дополнительных <tt><b>malloc</b></tt>'ов в начале!
</li>
<li>Копируем строку <tt><b>strdup</b></tt>'ом, отсекая лишнюю память после завершения строки, а указатель сохраняем в массив (<tt>Data[idx++] = strdup(buf)</tt>).
</li>
<li>После того, как главный цикл чтения файла по строкам закончен, в массиве <tt>Data</tt>, скорее всего, останутся незаполненные и неинициализированные ячейки. Что ж, добьём их контрольным <tt><b>realloc</b></tt>'ом! (<tt>num_lines = idx; Data = (char **) realloc(Data, num_lines * sizeof(char *))</tt>).
</li></ol>
Если убрать всё лишнее, то скелет получится примерно таким:

<tt>	char **Data = NULL;
	int num_lines = 0;
	int idx = 0;
	while (fgets(buf, sizeof buf, fInput)) {
		if (idx &gt;= num_lines) {
			if (num_lines == 0)
				num_lines = 2048;
			num_lines *= 2;
			Data = (char **) realloc(Data, num_lines * sizeof(char *));
		}
		Data[idx++] = strdup(buf);
	}
	Data = (char **) realloc(Data, idx * sizeof(char *));</tt>

где <tt>Data</tt> - наш считанный в память файл.
<i>Proof of concept</i> вы уже, разумеется, видели, когда изучали исходники моего <a href="../C1/formatter/utils.c" target="_blank"><b>Coding Style Checker</b>'а</a> - функцию
<tt>char **<b>read_file</b>(FILE *fInput, int *num_lines);</tt>
которую я также выделил отдельно в виде небольшого, но рабочего примерчика - <a href="../C2/adv/read_file.c" target="_blank">read_file.c</a>.
</li>
<li>Ну и, чтобы не плодить отдельную тему ради такой мелочи, давайте рассмотрим, как разбить строку на слова, если разделителем может быть любое количество пробелов и табов.
Если задача состоит всего лишь в том, чтобы считать в одномерный массив все числа с консоли или из файла, то и решение тривиальное:

<tt>#define N <i>побольше</i>
int main(void) {
	int n, A[N];
	for (n = 0; n &lt; N && scanf(<font color="green">"%d"</font>, &A[n]) == 1; n++);</tt>

Но если массив уже двумерный (матрица) и его хочется таким и оставить, то так легко уже не отделаемся. Или если читаем не из файла или консоли, а из строчки (буфера).
Но всё равно можно для этой цели запрячь <tt><b>sscanf</b></tt>, правда, придётся поплясать перед ним с бубном. Всего-то лишь стоит завести ещё один буфер <tt>char buf[4096]</tt> (в который будут временно складываться слова), а также указатель <tt>char *p</tt>, который надо настроить на исходную строку <tt>Buff</tt> и сдвигать потом. Сделать это можно изящно в одном заголовке цикла:

<tt>for (i = 0, p = Buff; sscanf(p, <font color="green">"%s"</font>, buf) == 1; i++, p = strstr(p, buf) + strlen(buf))
	A[i] = strdup(buf);</tt>

Пример, читающий двумерный массив с неизвестными размерностями, вы можете посмотреть в программе <a href="../C2/adv/sread.c" target="_blank">sread.c</a>.
</li></ol>
Итак, мы с вами теперь умеем всё. И если вам теперь дадут матрицу с неизвестными размерами, да без ограничений на длину строки, вы с помощью примеров <a href="../Assembler/buffered_input.c" target="_blank">buffered_input.c</a>, <a href="../C2/adv/read_string.c" target="_blank">read_string.c</a>, <a href="../C2/adv/read_file.c" target="_blank">read_file.c</a>, <a href="../C2/adv/sread.c" target="_blank">sread.c</a> и кусков кода в этом письме, сможете соорудить свой собственный всемогущий менеджер строк/слов.
Да, в каком-нибудь Perl, Python, Bash всё это уже встроено в сам язык и делается в 1,5 строчки. Но мы с вами прошли курс <b><i>Алгоритмы</i></b>, и мне хотелось бы, чтобы эти алгоритмы у вас остались (мало ли для чего их придётся приспособить!) То, что доступно в других языках, спокойно реализуется и на Си, и не то чтобы очень уж сложно.
Будьте здоровы!
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
