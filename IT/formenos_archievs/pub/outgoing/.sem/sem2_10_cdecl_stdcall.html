<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Семинар 10: Соглашения о вызовах cdecl и stdcall</title>
</head>
<body>
<div style="white-space: pre-wrap;">
Также приведу здесь пример полноценной функции, организующей <b><i>stack frame</i></b> (<b><i>кадр стека</i></b>):
<ol>
<li>Для начала соглашение <b>cdecl</b>:
<tt><font color="green">; начало функции</font>
my_func:
	<font color="green">; пролог функции - можно заменить на команду "<b>enter <i>M</i>, 0</b>", где <i>M</i> - суммарный размер всех локальных переменных</font>
	push ebp
	mov ebp, esp
	<font color="green">; выделяем в стеке память под все локальные переменные этой функции</font>
	sub esp, 8		<font color="green">; 4*m, где m - число int'овских переменных (в данном случае i и j)</font>
	<font color="green">; теперь [ebp-4] - это int i, [ebp-8] - это int j, хотя можно было и наоборот</font>

	<font color="green">; тело функции, здесь делаем что-то полезное</font>
	mov eax, [ebp+8]	<font color="green">; обращаемся к первому параметру функции</font>
	add eax, [ebp+12]	<font color="green">; ко второму</font>
	add eax, [ebp+16]	<font color="green">; к третьему</font>
	add eax, [ebp+20]	<font color="green">; к четвёртому</font>
	mov [ebp-4], eax	<font color="green">; сохраняем это зачем-нибудь в 1-ю локальную переменную (i)...</font>


	<font color="green">; эпилог функции - можно заменить на команду <b>leave</b></font>
	mov esp, ebp
	pop ebp

	ret			<font color="green">; выход из функции</font>
<font color="green">; конец функции</font></tt>
<font color="green">-------------------------------------------------------</font>
<tt><font color="green">; теперь мы где-то в main'е</font>
	...

	<font color="green">; заносим параметры в стек в обратном порядке</font>
	push dword [b]		<font color="green">; четвёртый параметр</font>
	push dword [a]		<font color="green">; третий параметр</font>
	push 2			<font color="green">; второй параметр</font>
	push eax		<font color="green">; первый параметр</font>
	call my_func		<font color="green">; вызов функции</font>
	<font color="green">; очищаем стек</font>
	add esp, 16		<font color="green">; 4*n, где n - число параметров функции</font>
	<font color="green">; анализируем возвращаемое значение функции...</font>
<font color="green">;	cmp eax, 10
;	j<i>cc</i> ...</tt></font>
<font color="green">-------------------------------------------------------</font>
</li>
<li>Теперь для <b>stdcall</b>. Начало функции точно такое же, всё то же самое, вплоть до выхода из функции.
<tt>	...
	<font color="green">; выходим из функции и очищаем стек от параметров</font>
	ret 16			<font color="green">; 4*n, где n - число параметров функции</font>
<font color="green">; конец функции</font></tt>
<font color="green">-------------------------------------------------------</font>
<tt><font color="green">; теперь мы где-то в main'е</font>
	...
	<font color="green">; заносим параметры в стек в обратном порядке</font>
	push ...		<font color="green">; n-ный параметр</font>
	push ...		<font color="green">; первый параметр</font>
	call my_func		<font color="green">; вызов функции</font>
	<font color="green">; стек не очищаем, т.к. он уже очищен командой <b>ret</b> с параметром</font></tt>
<font color="green">-------------------------------------------------------</font>
</li></ol>

Как выглядит стек, когда мы находимся внутри функции <b>my_func</b>, где-нибудь в середине:
<tt><i>0xFFFFFFFF</i>
<font color="green">-------------------------------------------------------</font>
	...
	envp			<font color="green">; параметр функции <b>main</b> - char *<b>envp</b>[] (опущено)</font>
	argv			<font color="green">; параметр функции <b>main</b> - char *<b>argv</b>[] (опущено)</font>
	argc			<font color="green">; параметр функции <b>main</b> - int <b>argc</b> (опущено)</font>
	ret.addr0		<font color="green">; адрес возврата в <i>startup code</i>, из которого был вызван наш <b>main</b></font>
	ebp0			<font color="green">; старое значение регистра ebp, которое использовалось в <i>startup code</i></font>
	...			<font color="green">; локальные переменные функции <b>main</b></font>
	...
	...			<font color="green">; временные данные, например, сохранённые регистры (если в коде <b>main</b> были всякие <b>push ebx</b> или <b>pushad</b>)</font>
<font color="green">-------------------------------------------------------</font>
	4			<font color="green">; 4-й параметр функции <b>my_func</b></font>
	...
	2			<font color="green">; 2-й параметр функции <b>my_func</b></font>
	1			<font color="green">; 1-й параметр функции <b>my_func</b></font>
	ret.addr1		<font color="green">; адрес возврата в <b>main</b></font>
	ebp1			<font color="green">; старое значение регистра ebp, которое использовалось в <b>main</b>'е</font>
	i			<font color="green">; локальная переменная функции <b>my_func</b></font>
	j			<font color="green">; ещё одна локальная переменная функции <b>my_func</b>. И уже не важно, какая из них 1-я, какая последняя, и в каком порядке они идут, главное - не запутаться самим.</font>
	...			<font color="green">; временные данные функции <b>my_func</b></font>
<font color="green">-------------------------------------------------------</font>
<i>0x00000000</i></tt>
Тут вы можете видеть 2 <b><i>кадра стека</i></b> (<b><i>stack frame</i></b>) для функции <b>main</b> и <b>my_func</b>. Таким образом, одна функция вызывает другую, другая третью и т.д. - получается <b><i>call stack</i></b> - <b><i>стек вызова функций</i></b>. Можно проследить, откуда мы были вызваны.

Соответствующие полные тексты этих примеров кода и листингов вы можете найти <a href="../Assembler/Windows/NASM32/Programs_libc/funcs" target="_blank">здесь</a>.
Возьмите и сравните какой-нибудь сравнивалкой, чем отличаются <a href="../Assembler/Windows/NASM32/Programs_libc/funcs/cdecl.asm" target="_blank">cdecl.asm</a> и <a href="../Assembler/Windows/NASM32/Programs_libc/funcs/stdcall.asm" target="_blank">stdcall.asm</a>.
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
