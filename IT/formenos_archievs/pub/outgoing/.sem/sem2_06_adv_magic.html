<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Урок 6: Контрольная магия</title>
</head>
<body>
<div style="white-space: pre-wrap;">
Ну, и в качестве ставшего уже традиционным вечера продвинутой магии предлагаю посмотреть, что творится за кулисами двух "неподъёмных" задач со 2-й контры прошлого семестра (прошлых годов).
Итак:
<ol>
<li><b>Сортировка функций</b>
Напомню условие задачи:
<i>"в функцию <tt>void <b>shake</b>(void *funcs, int n, int a, int b);</tt> под видом обобщённого нетипизированного указателя <tt>funcs</tt> прибывает массив (точнее, указатель на массив) из <tt>n</tt> указателей на функции, каждая из которых принимает два целочисленных параметра (типа <tt>int</tt>), выполняет над ними некоторую математическую операцию и возвращает результат (также типа <tt>int</tt>).
Отсортируйте эти функции в порядке возрастания их значения при аргументах <tt>a</tt> и <tt>b</tt>."</i>
Что мы имеем:
<ul>
<li><a href="../C2/adv/qsort_funcs.c" target="_blank">qsort_funcs.c</a> - решение задачи сортировки массива функций;
</li>
<li><a href="../C2/adv/qsort_funcs_footer.c" target="_blank">qsort_funcs_footer.c</a> - мой <tt>main</tt> со всякими прибамбасами, который цепляется к вашей посылке и который реализует ту самую дремучую чёрную магию, которую не каждый осмелится произнести вслух.
</li></ul>
Несколько комментариев по этой задаче.
<ul>
<li>Что такое
<tt>int <b>func</b>(int a, int b);</tt>
? Это <b><i>декларация</i></b> функции - её <i>сигнатура</i>.
Что такое <tt>func</tt> без скобок? Это указатель на функцию (на её начало ассемблерного кода). Это <u>константный</u> указатель, его можно читать, но нельзя менять.
А как сделать изменяемый? Да ещё так, чтобы саму функцию необязательно было описывать? А вот так:
<tt>int (*<b>p</b>)(int a, int b);</tt>
И теперь присваиваем:
<tt>p = func;</tt>
теперь можно вызывать <tt>p(5, 4);</tt> как будто <tt>func(5, 4);</tt> и наравне с нею.
<i>(Однако, если посмотреть под отладчиком-дизассемблером, то можно увидеть, что ассемблерные инструкции генерируются разные.)</i>
Обычная функция не может стоять в левой части присвоения, т.е. вот так нельзя: <tt><s>func = p;</s></tt> да и так тоже: <tt><s>func(a, b) = p;</s></tt>
</li>
<li>А как сделать <b><i>массив указателей</i> на функции</b>? Вспоминая и руководствуясь правилами <a href="http://habrahabr.ru/post/116255/" target="_blank">чтения крокодилов</a>, пишем:
<tt>int (*<b>A[100]</b>)(int a, int b);</tt>
Заполняем этот массив чем-то:
<tt>A[i] = func; ...</tt>
Вызываем:
<tt>A[i](5, 4); <font color="green">//ну а что, элемент A[i] - это же функция, точнее, указатель на неё...</font></tt>
</li>
<li>Теперь я хочу, чтобы массив <tt>A</tt> был не статический, а динамический. Как это мы делали для обычных целочисленных массивов?
Сравните, из обычного статического массива
<tt>int B[100];</tt>
получаем динамический
<tt>int *B;
B = (int *) malloc(100 * sizeof(int)); ...</tt>
Аналогично и для массива функций. Так что для <tt>A</tt> убираем квадратные скобки и ставим дополнительную звёздочку:
<tt>int (**<b>A</b>)(int a, int b);</tt>
выделяем память, инициализируем, заполняем, все дела...
</li>
<li>Вот именно такое безобразие к нам и прилетает в функцию <tt><b>shake</b>()</tt>. И именно его мы и редиректим напрямую в <tt><b>qsort</b>()</tt>. Даже приведения типов не нужны.
Вот как передать конкретные параметры <tt>a</tt> и <tt>b</tt> в функцию сравнения <tt><b>cmp_func</b>()</tt>?
Ничего лучше глобальных переменных я не придумал.
Ну хорошо. Если каждый элемент массива у нас типа <tt>int (*)(int a, int b)</tt>, то что же есть <tt>p1</tt> и <tt>p2</tt> в функции <tt><b>cmp_func</b>()</tt>? А это указатель на этот тип, т.е. то же самое, только добавляем ещё одну звёздочку: <tt>int (**)(int a, int b)</tt>.
Приводим типы указателей, разыменовываем (а как же?), получаем опять <tt>int (*)(int a, int b)</tt> - указатель на конкретную функцию. Но уже если теперь справа от него поставить круглые скобки, то это будет вызов функции по этому указателю. Дальше неинтересно.
</li></ul>
А казалось бы, всего 12 строчек. Но зато каких!
</li>
<li><b>Задача на строки</b> - на обработку текста, <i>aka</i> <b>мегазадача</b> из этого семестра. В контрольной работе она была в несколько урезанном варианте и только на Си.
<ul>
<li>Ещё когда я был студентом, она уже тогда была в задавальнике 2-го семестра, но с тех времён никто не решался сделать её в электронном виде, и даже я всего каких-нибудь 4 года назад считал, что её невозможно оцифровать (по крайней мере, в EJudge), ведь в совокупности это означало бы 6<sup>3</sup> = 216 вариантов, а на каждый вариант ещё по куче тестов - никаких EJudge'й не напасёшься!
До тех пор, пока мне в голову не сверкнули две блестящие идеи: 1) как это реализовать; 2) спонсорами тестов станут сами студенты! Именно поэтому в условии задачи появилась дополнительная функция <tt><b>test</b>()</tt>. Ну, первоначальную основу я, конечно, нагенерил.
Итак, знакомьтесь: <u>первая</u> (и единственная на данный момент) <u>на Физтехе задача на 216 вариантов с динамически пополняющейся базой тестов</u>.
Для реализации этой крайне амбициозной задачи мне пришлось превзойти самого себя в жонглировании тёмными трюками и покорить новые вершины тёмного искусства, которыми я с вами сейчас с удовольствием поделюсь. Хотя до нынешнего состояния эта задача доросла не сразу: 3 года назад <!--(у 53.1 группы)--> эта задача была намного проще, без <tt>main</tt>'а, с меньшим числом вариантов (множества полагались <tt>{ rule1 } = { rule2 }</tt>) и называлась она на 2-й контрольной <tt><b>text</b></tt>. К ассемблерному семестру я её существенно доработал.
</li>
<li>Но тут я выложу не решение, разумеется, а дополнительную служебную магию, которая сделала эту задачу возможной.
<a href="../C2/adv/mega_footer.c" target="_blank">mega_footer.c</a> - это то, что крепится снизу к вашей посылке с вашими функциями <tt><b>check</b>()</tt>, <tt><b>rule1</b>()</tt>, <tt><b>rule2</b>()</tt>, <tt><b>test</b>()</tt> и <tt><b>main</b>()</tt>. Или не крепится как часть исходника, а прилинковывается как второй модуль - едиственный способ сделать это не для языка Си, а для всевозможных диалектов Ассемблера x86.
Итак, смотрим мой модуль <a href="../C2/adv/mega_footer.c" target="_blank">mega_footer.c</a>, заложенный в систему. После интерфейсов четырёх ваших функций <tt><b>check</b>()</tt>, <tt><b>rule1</b>()</tt>, <tt><b>rule2</b>()</tt>, <tt><b>test</b>()</tt> следует...
<tt>int <b>_main</b>(int argc, char *argv[], char *envp[]);</tt>
Это ещё что такое?!
Должен признаться, что с самого же начала вас обманывают. Хотя ваша посылка должна быть самодостаточной программой с <tt>main</tt>'ом, чтобы вы могли локально её компилировать, запускать и отлаживать, но после отправки вашей посылки в систему я подделываю функцию <tt><b>main</b>()</tt>: у меня есть своя <tt><b>main</b>()</tt>, гораздо более хитрая, могущественная и зубодробительная, а вашу функцию я переименовываю в <tt><b>_main</b>()</tt> с подчёркиванием, которую затем и вызываю из своей (см. самую последнюю строчку) (и то не всегда), но перед этим ещё переделываю кучу полезных вещей.
</li>
<li>Как проверить, что вы действительно разделили свою программу на 3 функции <tt><b>check</b>()</tt>, <tt><b>rule1</b>()</tt>, <tt><b>rule2</b>()</tt> с корректными интерфейсами и обошлись без глобальных переменных и дополнительного выделения динамической (или даже статической) памяти, как было сказано в условии, а не сделали всё в одном <tt>main</tt>'е, как некоторые часто пытаются? Правильно, подёргать эти функции из моего секретного <tt>main</tt>'а.
А кто и когда использует вашу функцию <tt><b>test</b>()</tt>, если вы сами этого в вашем коде не делаете? Тоже, это всё он!
А вдруг мои тесты для конкретно данного варианта оказались слишком слабы, и у вас всё время вызывается, например, только <tt><b>rule1</b>()</tt>, но не <tt><b>rule2</b>()</tt>, или наоборот? Или вызываются, но комбинация вариантов сложилась так, что при данном условии одно из преобразований почти ничего не изменяет в тексте, а второе при этом написано некорректно? Тогда я для каждого теста из своего драгоценного <tt>main</tt>'а буду вызывать <b>И</b> <tt><b>rule1</b>()</tt>, <b>И</b> <tt><b>rule2</b>()</tt>, да ещё и покапризничаю и вашу функцию <tt><b>test</b>()</tt> заставлю выдавать что-нибудь разнообразное, чтобы обоим преобразованиям хватило.
Поскольку для вашего <tt>_main</tt>'а с главной логикой
<tt>if (<b>check</b>(s))
	<b>rule1</b>(s);
else
	<b>rule2</b>(s);
puts(s);</tt>
вызывается ЛИБО <tt><b>rule1</b>()</tt>, ЛИБО <tt><b>rule2</b>()</tt>, то я буду обе эти функции вызывать в безусловном порядке из своего <tt>main</tt>'а, да ещё и функцию <tt><b>check</b>()</tt> проверять, а результаты ... проверять здесь (в моём модуле) не стану, а то вы ещё научитесь из своего модуля вызывать мои эталонные реализации этих функций! Поэтому покамест я буду выписывать их в <tt>stdout</tt>, как в <i>лог</i>, а проверять будет другая программа - <b><i>чекер</i></b>, которая будет этот вывод парсить и сравнивать с тем, что выдадут эталонные функции.
Это мы всё рассмотрели <b><i>обычные тесты</i></b>, сгенерированные мною для всех 6<sup>3</sup> вариантов и лежащие статически в EJudge - обработка этого в исходнике со строчки 171 ("<tt><font color="green">//ordinary tests</font></tt>") и далее до конца этого злополучного модуля.
</li>
<li>Теперь разберём <b><i>юзерские тесты</i></b> (ваши) и наконец увидим, зачем нужна ваша функция <tt><b>test</b>()</tt>.
Найдите в коде строчку (~67):
<tt>if (strncmp(s, "User test # ", 12) == 0)</tt>
Тут отдельно обрабатывается случай, если на входе в тесте волшебное слово "<tt>User test # <i>такой_то</i></tt>", то это юзерский тест. Они всегда будут, для каждой посылки, для каждого варианта - первые три теста в этой задаче.
Но тут есть такая загвоздка: если я считаю первую строчку со <tt>stdin</tt>'а, проверю её, а это окажется не <tt>"User test # "</tt>, то когда я вызову ваш <tt><b>_main</b>()</tt>, ему уже нечего будет читать с экрана - всё уже считал я.
Поэтому тут я пошёл на хитрость. Пользуясь своим служебным положением, я, зная, из какого файла берутся данные в EJudge для перенаправления в ваш <tt>stdin</tt>, сам превентивно читаю из него строчку как из файла, а не как из <tt>stdin</tt>. А сам <tt>stdin</tt> не трогаю, а оставляю для вашего <tt>_main</tt>'а.
Затем самое интересное тут для вас - это как я извлекаю собственно номер - с помощью функции <tt><b>sscanf</b>()</tt>. Мы с вами знаем, что функции семейства <tt>*scanf</tt> хороши для парсинга - разбора выражений. Они даже поддерживают примитивные регулярки (<tt>man 3 scanf</tt>). (А функции семейства <tt>*printf</tt> - соответственно, наоборот, для синтеза форматированного текста, табличек и т.д.)
Смотрим далее...
<tt>p = T[x] = T[x] ? T[x] : strdup(test(x));</tt>
А это ещё что за приседания?! Зачем я написал <tt>T[x] = T[x]</tt>, уж не ошибся ли я с недосыпу? И почему бы просто не вызвать <tt>p = test(x);</tt>?
Дело в том, что изначально так и было, пока не нашлись умники, которые, поленившись придумать 3 разные строковые константы, возвращали мне из <tt>test</tt>'а указатель на один свой локальный строковый буфер, от вызова к вызову меняя в нём какой-нибудь символ. Естественно, у меня от этого всё посыпалось. Они нарушили мне <b><i>реентерабельность (идемпотентность)</i></b>, из-за чего сравнение тестов друг с другом (при повторном вызове <tt>test(x)</tt> с тем же номером) стало некорректно.
Поэтому для каждого <tt>x</tt> я <tt><b>test</b>()</tt> вызываю ровно один раз, сохраняя <b><i>копию</i></b> возвращённой строки себе в массив указателей <tt>T</tt>. И если <tt>T[x]</tt> непустой (не <tt>NULL</tt>), я в <tt>p</tt> записываю его, а если пустой, то вызываю <tt><b>test</b>(x)</tt>, беру от него копию и сохраняю её в <tt>T[x]</tt> и затем по цепочке передаю в <tt>p</tt>.
Таким образом, вызывается <tt><b>test</b>()</tt> с заданным номером и со всеми номерами, меньшими заданного; заданный сравнивается с предыдущими <tt>test</tt>'ами; несколько примитивных проверок и... тест выписывается в <tt>stdout</tt> (хотя он вроде как должен быть на входе), туда же, куда и результат!
Затем это всё проваливается в вызов <tt><b>check</b>()</tt>, <tt><b>rule1</b>()</tt> и <tt><b>rule2</b>()</tt> от юзерского теста, а ваш <tt><b>_main</b>()</tt> при этом не вызывается вообще!
Но на этом чудеса на виражах не заканчиваются. Если внимательно посмотреть протокол, а какой же ответ считается эталонным правильным для этих тестов, то мы увидим... три числа, например, "6 2 5" - номера ваших вариантов. Вы ещё не спятили? Всё просто: эта информация тоже понадобится <b><i>чекеру</i></b>.
Для <b><i>юзерских тестов</i></b> пришлось проверку правильности работы вашего решения выносить на уровень <b><i>чекера</i></b> - и писать для этой задачи <i>свой <b>чекер</b></i>, особенный, с юзерскими тестами и авторскими функциями. Т.е. я просто вашу реализацию <tt><b>check</b>()</tt>, <tt><b>rule1</b>()</tt> и <tt><b>rule2</b>()</tt> сравниваю со своими на всех таких тестах.
</li>
<li><b><i>Другие (все остальные, динамические) тесты</i></b>. Если вы подумали, что реализовать <b><i>юзерские тесты</i></b> для меня было самым сложным, то вы жестоко ошибаетесь.
Смотрим строчку (~36)
<tt>if (strncmp(s, "Other tests # ", 14) == 0)</tt>
Вам оно в протоколе тестирования не показывается, но это тот самый тест №74 (самый последний), который выглядит как-то так:
<tt>====== Test #74 =======
Other tests # 71
ABCC00a1bbbcccAYY22yAZ999zzQ
11$A00@11122-Z1_9991
AAA000aaaBBB111bbbYYY222yyyZZZ999zzz
...
hahaha
ha-ha-ha
...
<i>и далее идут все ваши юзерские тесты, которые вы когда-либо отправляли в EJudge в своих посылках в функциях <b>test</b>(), а также в задаче <b>append</b>.</i>
</tt>
Я извлекаю номер, идущий после <tt>"Other tests # "</tt> - это число строчек, которые можно пропустить из файла (были выше в тестах), а для всех остальных вызываю последовательно <tt><b>check</b>()</tt>, <tt><b>rule1</b>()</tt> и <tt><b>rule2</b>()</tt> по аналогии с <b><i>юзерскими тестами</i></b>.
На выходе в контесте будет подобная простыня:
<tt>
-- Users' test # 71 --
hahaha
-- check --
true
-- rule1 --
hahaha
-- rule2 --
hahaha

-- Users' test # 72 --
ha-ha-ha
-- check --
true
-- rule1 --
ha-ha-ha
-- rule2 --
ha-ha-ha
...
</tt>
которую будет парсить его величество <b><i>чекер</i></b>.
</li>
<li><a href="../C2/adv/check_mega.c" target="_blank">check_mega.c</a> - а вот и он. Вот эта штука компилируется и проверяет все ваши посылки по этой задаче на протяжении всей контрольной.
Эта программа открывает три файла на чтение (ввод, вывод вашей посылки (с моими добавками) и эталонный ответ), читает их построчно, сравнивает по некоторому алгоритму и в качестве кода возврата выдаёт вердикт (правильно, неправильно, плохой формат и т.д.).
Для <b><i>обычных тестов</i></b> хватает выходного и эталонного файлов (тут всё просто: построчное сравнение), а для <b><i>юзерских</i></b> и <b><i>динамических тестов</i></b> - еще дополнительную информацию из входного файла.
Чтение вывода (функция <tt><b>check_test</b>()</tt>) соответствует той же логике, которой следовал мой модуль с <tt>main</tt>'ом: последовательно извлекаются входная строка, результат ваших <tt><b>check</b>()</tt>, <tt><b>rule1</b>()</tt> и <tt><b>rule2</b>()</tt>.
</li>
<li>Как вы догадываетесь, раз уж ему приходится <b><u>проверять</u></b> все <b><i>юзерские и динамические тесты</i></b>, то он содержит реализацию всех вариантов функций <tt><b>check</b>()</tt>, <tt><b>rule1</b>()</tt> и <tt><b>rule2</b>()</tt>, которые я, конечно же, предусмотрительно убрал в "хедер" <tt>mega.c</tt> (я вам говорил, что так нельзя делать, но мне-то можно :-) ).
И из него нам больше всего интересны вот эти строчки:
<tt>static int (*<b>checks</b>[])(const char *s) = {check_1, check_2, check_3, check_4, check_5, check_6};
static void (*<b>rules1</b>[])(char *s) = {rule1_1, rule1_2, rule1_3, rule1_4, rule1_5, rule1_6};
static void (*<b>rules2</b>[])(char *s) = {rule2_1, rule2_2, rule2_3, rule2_4, rule2_5, rule2_6};</tt>
Что это такое - мы уже знаем - массивы функций. Индексы в этих массивах - это номера вариантов, которые я извлекаю из файла с эталонным ответом. Поэтому теперь понятно, что в функции <tt><b>check_test</b>()</tt> вот это, например:
<tt>rules1[r1-1](s1);</tt>
</li>
<li>И, наконец, разоблачение секретов верховной магии.
Моя <b><i>чекерная</i></b> функция <tt><b>check</b>()</tt>, заметив <b><i>юзерский тест</i></b>, прежде чем вернуть вердикт проверки от <tt><b>check_test</b>()</tt>, вызывает функцию <tt>add_test(s1);</tt> которая проверяет, нет ли этого теста уже в динамической базе (функция <tt><b>has_test</b>()</tt> - проверка наличия строки в файле), и если нет, то добавляет его. Предварительно, конечно, ищет этот файл в файловой системе как файл с наибольшим номером в имени (<tt><b>get_max_test_num</b>()</tt>).
</li>
<li>Поскольку все варианты этой задачи организованы с помощью магических <b><i>симлинков</i></b>, то добавление нового <b><i>юзерского теста</i></b> моментально отражается во всех 6<sup>3</sup> вариантах в виде добавления в список <b><i>других (динамических) тестов</i></b>. Вуаля, круг замкнулся, теперь всё стало на свои места!
</li>
<li>Всё остальное в этой программе - это упражнения со строками и чтение файлов.
</li>
<li>Где-то в недрах файловой системы был ещё один таинственный файлик - <tt>mega_gen.c</tt> - низкоуровневый "скрипт" на языке Си на 300 строк, который из файла с условиями и файла с несколькими тестами (только input) генерировал 216 вариантов этой задачи, но это уже совсем другая история. Спокойной ночи, Страна! ©
</li>
</ul>
</li>
</ol>
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
