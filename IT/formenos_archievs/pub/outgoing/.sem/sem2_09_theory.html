<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Семинар 9: Защищённый режим, плоская модель памяти; процедуры/функции в Ассемблере - Теория</title>
</head>
<body>
<div style="white-space: pre-wrap;">
<ul>
<li>Теоретический материал по <b>защищённому режиму</b> можно почерпнуть из Википедии:
<ul>
<li><a href="http://ru.wikipedia.org/wiki/Защищённый_режим" target="_blank">Защищённый режим</a> (до раздела "Каталог и таблицы страниц", который можно просмотреть поверхностно)
</li>
<li><a href="http://ru.wikipedia.org/wiki/Сегментная_адресация_памяти" target="_blank">Сегментная адресация памяти</a>
В современных системах сегментация не используется, но вы должны хотя бы понимать разницу между сегментами и страницами:
С помощью сегментов описывается <u>двухуровневая</u> модель памяти в формате "<tt>сегмент:смещение</tt>", с этим имеет дело сам программист, который представляет себе память примерно так:
<tt>сегмент1
    смещение1 (т.е. короткий адрес)
    смещение2
    ...
    смещениеN
сегмент2
    смещение1
    смещение2
    ...
    смещениеM
...</tt>
а с помощью страниц реализуется плоская (<i>flat</i>) модель памяти:
<tt>    смещение 1
    смещение 2
    ...
    смещение 4294967296</tt>
и управляется это целиком операционной системой и железом.
Кроме того, сегменты имеют переменные размеры (в защищённом режиме) и могут пересекаться, а страницы все фиксированного размера (чаще всего 4KB) и не могут пересекаться, следуют друг за другом, поэтому начинаются все с адреса, кратного размеру страницы (4096).
</li>
<li>Подробнее про сегментацию можно прочитать тут:
<a href="http://ru.wikipedia.org/wiki/80286#.D0.9E.D1.80.D0.B3.D0.B0.D0.BD.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.BF.D0.B0.D0.BC.D1.8F.D1.82.D0.B8" target="_blank">Организация памяти</a> (до раздела "Кольца защиты"), но не вдавайтесь в технические детали, главное понять суть.
</li>
Далее.
<li><a href="http://ru.wikipedia.org/wiki/Страничная_память" target="_blank">Страничная память</a> (до "Отображаемые в память файлы"; раздел "Концепции" можно читать по диагонали, не вдаваясь в подробности про количество флажков в записях таблицы страниц и в размеры таблиц страниц в тех или иных моделях/режимах)
</li>
<li><a href="http://ru.wikipedia.org/wiki/80386" target="_blank">80386-й процессор</a> (до "Страничное преобразование" и можно прочитать чуть-чуть дальше по желанию)
</li></ul>
Имейте в виду, что в Википедии и в задаче simple_page иногда путают понятия <b><i>"логический"</i></b>, <b><i>"линейный"</i></b>, <b><i>"виртуальный"</i></b> и <b><i>"физический"</i></b> адреса. Если запутаетесь, то можете почитать разъяснения <a href="https://habrahabr.ru/company/intel/blog/238091/" target="_blank">здесь</a>.
Мы будем следовать именно этой терминологии. Т.е.,
<b><i>"виртуальный адрес"</i></b> - адрес, указанный в ассемблерной программе или в дизассемблерном листинге (отладчике);
<b><i>"логический адрес"</i></b> - это пара "<tt>сегмент:смещение</tt>";
<b><i>"линейный адрес"</i></b> - это результат вычисления "<tt>база_сегмента + смещение = линейный_адрес</tt>";
<b><i>"физический адрес"</i></b> - понятно, адрес, который подаётся в планку оперативки.
Если страничного преобразования нет (реальный режим или защищённый с отключенным страничным преобразованием), то линейный адрес совпадает с физическим.
<b><i>Виртуальный адрес</i></b>, в зависимости от контекста и режима  работы процессора, может совпадать с любым из трёх остальных типов адресов. Но главное - это тот адрес, который имеет в виду программист. В современных 32- и 64-битных системах виртуальным адресом называют вторую часть логического адреса ("<tt>смещение</tt>"), которое затем в MMU автоматически разбивается на 2-3 части и с помощью таблиц страниц переводится в физический.
На шину адреса процессор выставляет, конечно, физический адрес. Однако, если проц древний и не имеет MMU (или оно внешнее), и шина адреса другая, то выставляется линейный адрес, как и написано в Википедии.

Материала много, и он сложный, перегруженный излишними техническими подробностями. Читать его нужно выборочно, фильтруя ненужное в соответствии с тем, что я рассказывал на семинаре.
</li>
<li><b>Процедуры/функции</b> в Ассемблере, использование <b>стека</b> при этом:
Читаем про команды <a href="http://web.archive.org/web/20150528230750/http://www.kolasc.net.ru/cdo/programmes/assembler/call.html" target="_blank">call</a> и <a href="http://web.archive.org/web/20150828031025/http://www.kolasc.net.ru/cdo/programmes/assembler/ret.html" target="_blank">ret</a> на <a href="http://web.archive.org/web/20150512184626/http://www.kolasc.net.ru/cdo/programmes/assembler/tc.html" target="_blank">kolasc.net.ru</a>, но не увлекайтесь реальным 16-битным режимом;
про необязательный параметр <a href="http://web.archive.org/web/20150828031025/http://www.kolasc.net.ru/cdo/programmes/assembler/ret.html" target="_blank">ret</a> поговорим на следующем занятии.
</li>
</ul>
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
