<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Алгоритмическая сложность - Теория</title>
</head>
<body>
<div style="white-space: pre-wrap;">
Понятие алгоритмической (вычислительной) сложности можно почерпнуть хотя бы здесь:
<ul>
<li><a href="http://ru.wikipedia.org/wiki/Вычислительная_сложность" target="_blank">http://ru.wikipedia.org/wiki/Вычислительная_сложность</a>
</li>
<li><a href="http://www.wikiznanie.ru/ru-wz/index.php/Классификация_задач" target="_blank">http://www.wikiznanie.ru/ru-wz/index.php/Классификация_задач</a>
</li></ul>
Всё можно не читать, только основное.

  Коротко, про асимптотические оценки, ибо пользоваться этим будете часто.
  Говорят, что если оценка есть <tt>O(n)</tt>, или <tt>O(n<sup>2</sup>)</tt>, или ... <tt>O(n<sup>a</sup>)</tt>, где <tt>a</tt> - константа, то алгоритм называется полиномиальным (если показатель степени <tt>n</tt> небольшой, то ещё и называется эффективным).
Ну, например, простейшая сортировка массива методом выбора имеет сложность <tt>O(n<sup>2</sup>)</tt>. <i>[Православные сортировки имеют сложность <tt>O(n*log(n))</tt>.]</i> Что это означает?
Что если мы будем увеличивать длину входа в <tt>n</tt> раз, то количество операций, выполняемых компьютером, будет увеличиваться в <tt>C*n<sup>2</sup></tt> раз, где <tt>C</tt> - некая константа.
Например, если увеличить <tt>n</tt> в 5, 10, 20, 30, 40 раз, а <tt>C</tt>=2, то количество операций будет увеличиваться в 2*5<sup>2</sup> = 50, 2*10<sup>2</sup> = 200, 2*20<sup>2</sup> = 800, 2*30<sup>2</sup> = 1800, 2*40<sup>2</sup> = 3200 раз.
А вот если алгоритм имеет сложность <tt>O(2<sup>n</sup>)</tt>, или вместо 2 любое другое константное основание, то его называют экспоненциальным (пример - любой переборный алгоритм).
Тогда, даже если <tt>C</tt>=0.5, то при увеличении длины входа в 5, 10, 20, 30, 40 раз количество операций будет увеличиваться соответственно в 0.5*2<sup>5</sup> = 16, 0.5*2<sup>10</sup> = 512, 0.5*2<sup>20</sup> = 524288, 0.5*2<sup>30</sup> = 536870912, 0.5*2<sup>40</sup> = 549755813888 раз. Что называется, почувствуйте разницу.
  Теперь, что такое вообще длина входа и количество операций, в чём их мерить? <tt>n</tt> - это биты, символы или количество строк? А количество операций - это ассемблерные команды, количество шагов Машины Тьюринга, операторы C или что-то ещё?
А вот в том-то и дело, что неважно, ведь у нас оценка не абсолютная, а асимптотическая, нам важно лишь, как меняется относительная скорость работы алгоритма по сравнению с относительным изменением количества входных данных, поэтому все эти конкретные коэффициенты попадут в это <tt>O</tt>. Главное, какие команды мы обзовём элементарными.
Ясно, что какой-нибудь метод <tt>list.sort()</tt> не тянет на элементарную.
  Как получить эту оценку? Правильный ответ - подумать головой. И решить задачку: во сколько раз увеличится количество операций при увеличении длины входа в 10, 20, 30, 40 раз? и увидеть эту функцию <tt>f(n)</tt>. Иногда придётся доказать теоремку.
  На практике обращают внимание на количество итераций циклов, на уровень вложенности циклов, и на вызовы функций, зависящих от <tt>n</tt>.
Простой цикл <tt>for (int i = 0; i &lt; n; i++) {...}</tt> даёт оценку <tt>O(n)</tt>, двойной цикл <tt>for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) {...}</tt> уже <tt>O(n<sup>2</sup>)</tt>, если их тела тривиальны и не зависят от <tt>n</tt>.
Если в теле циклов вызываются функции, которые сами по себе тоже зависят от <tt>n</tt>, то это добавляет сложности и это тоже надо учитывать.
Контрпример - задачи <a href="../C1/factors.c" target="_blank">factors</a>/divisors. Не любой вложенный цикл приводит сразу к <tt>O(n<sup>2</sup>)</tt>.
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
