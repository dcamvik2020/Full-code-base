<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Семинар 8: Структуры, строки, указатели - Теория</title>
</head>
<body>
<div style="white-space: pre-wrap;">
<!--Из-за того, что у нас с вами пропадает следующее после контрольной занятие (5 ноября), нам пришлось взять довольно много сложных тем, поэтому занятие получилось полностью теоретическим - мы не только не успели порешать задачек на семинаре, но и я не успел рассказать всё, что хотел. Поэтому вся практика осталась вам на дом.
Кроме того, некоторые моменты мне показались смазанными, поэтому я решил в этот раз расписать теорию по указателям поподробнее, чего раньше никогда не делал.
-->
<ol>
<li>Мы освоили новые (пользовательские) типы данных:
<ol>
<li>Создание синонимов (алиасов) типов с помощью <tt><b>typedef</b></tt>.
Иногда тип переменной или выражения становится настолько громоздким и страшным (мы с вами столкнёмся с такими на следующем занятии), что становится целесообразным "создать" новый тип с коротким именем и такими же свойствами. Синтаксис:
<tt><b>typedef</b> old_type new_type;</tt>
Например, было:

<tt>double f = ...;
unsigned long long int L = (unsigned long long int) f;</tt>

С помощью введения нового имени <tt>uint64</tt> становится:

<tt><b>typedef</b> unsigned long long int   uint64;
double f = ...;
uint64 L = (uint64) f;</tt>
</li>
<li>Композитные типы данных - <b>структуры</b>. Применяются, когда несколько разнотипных данных имеет смысл объединить в один тип.
<a href="sem1_08_struct.html">Пример описания структуры</a>
Дальше по теории структур из моих материалов - наверное, только основной словарик, из не моих - любая книжка.
</li></ol></li>
<li><b>Строки.</b>
Вспоминаем про часть Сишно-Паскалевского <a href="../Materials/Pascal-C_string.pdf" target="_blank">словарика</a>, там есть масса полезных функций для работы со строками.
В Си строки - это цепочка (массив) char'ов, которая обязательно заканчивается символом с кодом 0 (символ <font color="green">'\0'</font>). Под этот <font color="green">'\0'</font> тоже должно быть предусмотрено место в массиве. Строковые <b><u>константы</u></b>, обрамлённые двойными кавычками (например, <font color="green">"Hello"</font>), всегда неявно содержат <font color="green">'\0'</font> в конце (компилятор подставляет), именно поэтому <tt><b>sizeof</b> <font color="green">"Hello"</font></tt> равно 6, а не 5.
Если вы забыли после вашей строки поставить <font color="green">'\0'</font> или в результате ваших манипуляций он был затёрт, то ждите выхода за границы массива и сообщений Валгринда о "<tt>Conditional jump or move depends on uninitialised value(s)</tt>", ибо все функции стандартной библиотеки Си (<tt><b>strlen</b></tt>, <tt><b>strcpy</b></tt>, <tt><b>strcat</b></tt>, <tt><b>strcmp</b></tt>, <tt><b>strchr</b></tt>, <tt><b>strstr</b></tt>, <tt><b>printf</b></tt>, <tt><b>puts</b></tt>, ...) бегут по строке до тех пор, пока этот самый <font color="green">'\0'</font> таки не найдут. Ну или не наступит <tt>Segmentation fault</tt>.

Однако, по иронии судьбы, не все функции завершающий ноль <font color="green">'\0'</font> выставляют в конце строки, поэтому надо быть осторожным. Вот краткая статистика:
<ul>
<li><tt><b>gets</b>()</tt>, <tt><b>scanf</b>()</tt> - удаляют <font color="green">'\n'</font>, но ставят <font color="green">'\0'</font>, даже если при этом выходят за границы массива;
</li>
<li><tt><b>fgets</b>()</tt> - оставляет <font color="green">'\n'</font> (если он был на входе и если он уместился в ограничение) и ставит <font color="green">'\0'</font>; если задать корректные ограничения (для <b><u>статических</u></b> массивов: <tt><b>sizeof</b>(s)</tt>), то выхода за границы массива не будет, всё хорошо;
</li>
<li><tt><b>strcpy</b>()</tt>, <tt><b>strcat</b>()</tt> - ставят <font color="green">'\0'</font>, даже если при этом выходят за границы массива;
</li>
<li><tt><b>strncpy</b>()</tt> - <u>НЕ СТАВИТ</u> <font color="green">'\0'</font>, если строка оказалась равна или длиннее n ! А если меньше, то дописывает нулей до достижения n символов;
</li>
<li><tt><b>strncat</b>()</tt> - ставит <font color="green">'\0'</font>, но если строка равна или длиннее n, то на (n+1)-ю позицию (считая от 1, от начала присоединённой подстроки).
</li></ul>
Вот такая вот путаница.
</li>
<li><b><a href="sem1_08_pointers.html">Указатели</a>.</b> At long last.
Мы с вами успели только начать, так что пока это только введение. На следующем после к/р семинаре продолжим их изучать, дам вам более полную теорию по указателям.
У вас есть две недели, чтобы с ними разобраться и к ним привыкнуть.
Настоятельно рекомендую почитать ещё дополнительно какую-нибудь литературу на эту тему (на самом деле, подойдёт любой учебник, хоть Керниган-Ритчи, хоть Подбельский)<!--, особенно это касается отсутствующих-->. Указателями мы будем пользоваться далее на каждом шагу, поэтому эту тему не запускать, разобраться в ней нужно полностью, и как можно скорее. Язык Си немыслим без указателей. Если не получается разобраться, пишите. Задавайте свои вопросы на семинарах и по почте.
</li>
</ol>
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
