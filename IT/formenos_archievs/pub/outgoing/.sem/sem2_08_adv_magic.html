<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Урок 8: [Advanced Magic] Буферизация или Чем заменить fgets и scanf</title>
</head>
<body>
<div style="white-space: pre-wrap;">
Продолжаем цепочку писем-только-для-крутых. И сегодня поподробнее разберём малую часть того, что творится за кулисами всяких там <tt><b>fgets</b>()</tt>, <tt><b>scanf</b>()</tt> и пр.

Как вам, надеюсь, известно, <tt><b>fgets</b>()</tt> (да и <tt><b>gets</b>()</tt>) считывают откуда-надо строчку до символа <font color="green">'\n'</font>, таким образом позволяя побить входной поток символов на строчки. Точно так же можно справиться и с файлами, и со всем, что можно открыть через <tt><b>fopen</b>()</tt> и что имеет "тип" <tt>FILE*</tt>. Но что делать, когда у вас по тем или иным причинам нет такой замечательной возможности (несовместимость? отключили <tt><b>libc</b></tt> за неуплату??), и вам приходится самостоятельно искать, где же конец одной строки и начало другой?
Ну, вот вам пример из жизни: вы пишете программу-сервер, общающуюся с клиентом, открыли сокет (сетевое соединение), поэтому вы можете пользоваться только низкоуровневыми функциями <tt><b>send</b>()</tt> (или <tt><b>write</b>()</tt>) и <tt><b>recv</b>()</tt> (или <tt><b>read</b>()</tt>). И если с отправкой сообщений всё более-менее просто и понятно, то <tt><b>recv</b>()</tt> принимает сырой поток байт и заполняет его в переданный ей массив-буфер, оставляя удовольствие отделять одну строчку от другой - вам. Ситуация осложняется тем, что какая-то строчка может не уместиться в ваш массив-буфер и следующий кусок строки будет передан вам при следующем вызове функции <tt><b>recv</b>()</tt> (<tt><b>read</b>()</tt>).
Таким образом, намечается уже две проблемы:
<ol>
<li>в буфере 2 или более строк, т.е. содержатся символы <font color="green">'\n'</font>;
</li>
<li>в буфер поместилась строчка не полностью, а только кусок, а остальные куски - в следующий раз.
</li></ol>
Или другой случай: пусть будет не последовательность строчек, а последовательность чисел. Пример: даны 5 чисел, а размер вашего массива-буфера всего 16 байт (<tt>char array[16];</tt>):

<tt>"123  321   1234567 -12 -210"
         array1  |   array2</tt>

Как превратить эту чересчур длинную строчку в 5 чисел?
Как видите, мало того, что числа разделяются разным числом пробелов, так ещё и число <tt>1234567</tt> распополамило, кусок его в одном массиве (первый вызов функции <tt><b>read</b>(fd, array, 16)</tt>), кусок в другом (второй вызов <tt><b>read</b>(fd, array, 16)</tt>).
Как организовать нормальный непрерывный приём строчка-за-строчкой или число-за-числом? Тут поможет вам такой полезный метод, как буферизация.
Готовая моя реализация лежит <a href="../Assembler/buffered_input.c" target="_blank">здесь</a>, посмотрите.

Идея предельно простая и кристальная. Заводим один массив - буфер <tt>char buffer[N]</tt> неважно какой длины и целое число <tt>index</tt>, которое пробегает значения от <tt>0</tt> до <tt>N-1</tt> - "указатель" на текущий символ, считываемый из буфера. Ключевая функция - <tt><b>getchr</b>()</tt>, которая чаще всего считывает очередной символ из этого массива-буфера и увеличивает <tt>index</tt>. И только когда системный буфер считан весь до конца, она заполняет его следующим куском (вызывает <tt><b>fillbuf</b>()</tt>, которая вызывает низкоуровневые функции <tt><b>read</b>()</tt> или <tt><b>ReadFile</b>()</tt> и сбрасывает <tt>index</tt>). Единственная моя хитрость - я резервирую место в буфере под <font color="green">'\0'</font>, чтобы он всегда гарантированно там был. А все остальные функции (<tt><b>getstr</b>()</tt> и <tt><b>getnum</b>()</tt>) работают уже через эту функцию <tt><b>getchr</b>()</tt>.
Функция <tt><b>getstr</b>()</tt> набирает в пользовательский буфер строчку по буквам, пока не встретит <font color="green">'\n'</font> (закомментированное можно не смотреть). При этом, записывать ли сам <font color="green">'\n'</font> или нет - вопрос спорный. Можно реализовать два варианта этой функции (как, например, сделано в <tt><b>fgets</b>()</tt> и <tt><b>gets</b>()</tt>).
А <tt><b>getnum</b>()</tt>, по сути, это первая половина задачи <a href="../C2/any.c" target="_blank">any</a>, только исходные символы она берёт не с консоли, а запрашивает у <tt><b>getchr</b>()</tt>. И ещё она предварительно пропускает все пробельные символы (пробелы, табы, переходы на новую строку), как это делает и <tt><b>scanf</b>()</tt>.

Собственно, это всё, что касается input'а, именно это и реализовано на ассемблере в первой половине моей библиотечки <a href="../Assembler/Windows/NASM32/Programs/ioproc.asm" target="_blank">ioproc.asm</a>. С output'ом проще, там сделано без буферизации.
Посмотрите, теперь, надеюсь, не испугаетесь.

Я не хочу говорить, что это основа реализации <tt><b>scanf</b></tt>'а - он делает ещё очень много-много чего, как минимум, парсит строку шаблонов. Но это можно рассматривать как скелет алгоритма <tt><b>scanf</b></tt>'а для чисел и <tt><b>gets</b></tt>'а.

Основной недостаток данного решения - плохая расширяемость (что делать, если хочется читать из двух-трёх-n сокетов попеременно?) и, соответственно, не <i>thread-safety</i> (не <i>потокобезопасно</i>). Пути выхода из ситуации - выделять буфер динамически, ещё выделять динамически некоторую структуру, в которую складывать указатель на этот буфер и <tt>index</tt> и выдавать указатель на эту структуру пользователю при инициализации очередного буферизованного потока ввода. Получится что-то типа <tt><b>fopen</b>()</tt> и <tt>FILE*</tt> собственной персоной.
Но это упражнение я оставляю вам для самостоятельного развития. ;-)
Оставайтесь с нами.
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
