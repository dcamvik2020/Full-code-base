<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Урок 5: Искусство визуализации данных - Продвинутая магия</title>
</head>
<body>
<div style="white-space: pre-wrap;">
4 часа <s>утра</s> ночи - самое время для продолжения Уроков <font color="green">Продвинутой Магии</font>. И теперь пришло время поподробнее написать про долгожданный и многообещанный сурпрыз, который я <s>поза</s>вчера вам продемонстрировал (и который отнял у меня достаточно много сил и времени).
Я думаю, все мы в детстве любили рисовать. И поэтому у вас есть замечательная возможность совместить приятное с полезным - удовольствие от творчества-художества и практика визуализации своих научных достижений. Более того, на сей раз вы не скованы узкими рамками строгого дядюшки Еджуджа - дайте волю фантазии, нарисуйте не только одну какую-то элементарную функцию (чего, в принципе, достаточно для зачтения задачи) (sin не брать - он уже занят мной), но что-нибудь поистине клёвое. Можно, например, взять функцию из нашей задачи <b>calc1</b> и подключить её как модуль (или как <a href="../C2/drawing/drawing_release/calc.dll" target="_blank">библиотеку</a>), и перед вами основа не самого плохого графёра (см, например, мою <a href="../C2/drawing/drawing_release/drawing.exe" target="_blank">реализацию</a> или мою школьную поделку <a href="../C2/drawing/drawing_release/Functions.exe" target="_blank">Functions.exe</a>; не сказал бы, что это образец для подражания, но чтобы вдохновиться, сойдёт; главное, включите в Настроечках шкалу и т.д. - кнопка молотка). А ещё можно... придумать что-нибудь своё! Вообще говоря, данная заготовка могла бы послужить основой для курсового проекта в 4-м семестре...
Но обо всём по порядку.

<b>Лирическое отступление</b>
Итак, после того, как мы частично-успешно изучили язык Си и даже некоторые Алгоритмы, надо научиться создавать GUI-шные приложения (Graphical User Interface). Естественно, в данном случае не на чистом WinAPI или X-ах. Давным-давно придумали разнообразные библиотеки, которые, используя WinAPI или Иксы, бОльшую часть реализации GUI берут на себя, оставляя разработчику лишь удобные интерфейсы - ниточки и рычажки, за которые надо дёргать, чтобы приложение ожило и работало. Ну, например, библиотека Qt. Среди прочих её отличает, что она:
<ol>
<li>На C++. В принципе, совместимая с тем, что мы рассматриваем в нашем курсе.
</li>
<li>Нативная, не навязывает Managed code. В отличие от Windows Forms в Visual Studio, где вы все указатели и массивы вынуждены переделывать в чёрти чё.
</li>
<li>Кроссплатформенная. Ваше приложение, написанное в Windows, обычно достаточно лишь перекомпилировать в Linux. (Точнее, мультиплатформенная. Кроссплатформенная - это Java, т.к. там даже перекомпилировать не надо, даже для 32- или 64-битных версий).
</li>
<li>Живая, развивающаяся, поддерживаемая.
</li>
<li>Бесплатная, открытая, хорошая, добрая, прекрасная, ... :-)
</li></ol>
Ну, короче, теперь вы понимаете, почему мы с самого начала учебного года взяли именно эту IDE. ;-)
<ol>
<b>00.</b>
...Выбираем пункт меню (далее - <b><i>п.м.</i></b>) <i>Файл -&gt; Новый файл или проект -&gt; Приложения -&gt; Приложение Qt Widgets</i> (в разных версиях Qt менюшки могут быть разные). Далее всё как обычно: <i>Далее, Далее, Далее</i>... И вуаля, перед нами наше первое, уже готовое GUI-шное приложение, даже в редакторе кода уже что-то написано. Компилируем, запускаем и радуемся: перед нами графическое окно, которое всё, что умеет, - это просто... быть. Ну, ладно, ещё рождаться, сворачиваться-разворачиваться, ресайзиться и умирать. Что, в принципе, уже не так мало.
Но так как мы хотим бОльшего, то в секции <i>Проекты</i> открываем узел <i>Формы</i> и дважды щёлкаем <a href="../C2/drawing/1_drawing_button/mainwindow.ui" target="_blank">mainwindow.ui</a>. Вместо редактора кода открывается Дизайнер формы, на которой мы настраиваем внешний вид приложения: добавляем новые компоненты (они же виджеты, они же контролы) - перетаскиваем слева кнопочки (<b>Push Button</b>), поля ввода (<b>Line Edit</b>), надписи (<b>Label</b>) и что-нибудь ещё для разнообразия. Затем редактируем их свойства в окошке справа. Например, свойство <b>text</b>; остальные изучите по мере надобности; справка и онлайн-документация вам в помощь...

<b>0.</b>
Как видите, создание внешнего вида вашего приложения не сложнее, чем играть в детские кубики. Занятие не столь достойное физтеха.
Но это только внешний вид. Запустив приложение и пожмакав по кнопке, мы констатируем, что ничего не происходит. Ибо надо ещё сделать и реакцию на разные действия пользователя.
А для этого придётся вернуться в Редактор кода (вторая сверху кнопка слева в Qt).
Переключаемся на <a href="../C2/drawing/1_drawing_button/mainwindow.h" target="_blank">mainwindow.h</a> и <a href="../C2/drawing/1_drawing_button/mainwindow.cpp" target="_blank">mainwindow.cpp</a>, видим там много непонятного. Увы, чтобы этим всем овладеть, надо изучить ООП, и тут я могу вас только отослать к соответствующим профильным книжкам. А пока что, в рамках нашей задачи, попробую кратко прокомментировать сгенерированный код.
</ol>
<b>ООП за 21 минуту</b>
<ul>Каждый зримый контрол (и не только он), в т.ч. главное окно <b>MainWindow</b>, представляется классом (<b><i>class</i> MainWindow</b>), интерфейс которого прописан в файле <i>класс.h</i>, а реализация в <i>класс.cpp</i>.

<li><b><i>Класс</i></b> в C++ - это, грубо говоря (на самом деле, совсем грубо и поверхностно), структура (<b><i>struct</i></b>), в которой кроме полей, есть ещё функции, которые относятся только к этому классу, называемые <b><i>методами</i></b>.
</li>
<li><b><i>Объект</i></b> - это экземпляр <b><i>класса</i></b>, другими словами это переменная типа <b><i>класс</i></b>. (Аналогично можно сказать, что и обычная <b><i>переменная</i></b> - это экземпляр <b><i>типа</i></b>.)
</li>
Например, кнопка <b>PushButton</b> - это <b><i>класс</i></b>, но мы на форму можем накидать 3 кнопки (экземпляра этого <b><i>класса</i></b>), каждую из которых будет представлять свой отдельный <b><i>объект</i></b>.
Обычно <b><i>методы</i></b> работают с полями <b><i>объекта</i></b> и с переданными параметрами. Есть ещё два особых <b><i>метода</i></b> - <b><i>конструктор</i></b> и <b><i>деструктор</i></b>. 

<li><b><i>Конструктор</i></b> записывается так:
<tt><b>Имя_Класса(параметры);</b></tt>
т.е. как и любой другой метод, только имя его = имени класса, а указывать возвращаемое значение функции нельзя.
<b><i>Конструктор</i></b> вызывается только один раз при создании каждого <b><i>объекта</i></b>. 
</li>
<li><b><i>Деструктор</i></b> записывается аналогично, только ещё с тильдой и без параметров:
<tt><b>~Имя_Класса();</b></tt>
вызывается, соответственно, при уничтожении <b><i>объекта</i></b> и нужен для освобождения занятых ресурсов.
</li>
<li>Классы могут <b>наследовать</b> друг друга:
<tt>class A {
...
};
class B: <b>public A</b> {
...
};</tt>
Родительский класс <b>A</b> при этом называется <b><i>базовым классом</i></b>, а дочерний <b>B</b> - <b><i>наследником</i></b>. Наследник имеет все те же поля и методы, что и базовый класс (кроме тех, которые из секции <font color="olive">private</font>), (они не дублируются), плюс ещё может добавлять какие-то свои. Или переписывать (переопределять) методы базовых классов.
</li></ul>
Поскольку у нас объявление и реализация класса <font color="purple">MainWindow</font> разнесены, то в <a href="../C2/drawing/1_drawing_button/mainwindow.cpp" target="_blank">mainwindow.cpp</a> мы видим имплементацию методов класса (пока только конструктор и деструктор). И чтобы их отличить от прочих функций программы, указывается не просто имя метода, но <b>полное квалифицированное имя</b>, с указанием имени класса (и, возможно, namespace) через операцию расширения области видимости <tt><b>::</b></tt> как-то так:
<tt><font color="navy">тип Имя_Класса::Имя_Метода(параметры) {тело}</font></tt>
Пока что в нашем случае видим инициализацию, настройку и уничтожение поля <tt><font color="maroon">ui</font></tt>, который управляется графическим дизайнером и в который лезть не только не нужно на данном этапе, но и вредно.
В блоке инициализации конструктора между <tt><b>:</b></tt> и <tt><b>{</b></tt> видим вызов конструктора <b><i>базового класса</i></b> <tt><font color="purple">QMainWindow</font>(parent)</tt> и инициализацию поля <tt><font color="maroon">ui</font>(<font color="olive">new</font> <font color="purple">Ui</font>::<font color="purple">MainWindow</font>)</tt>, но на это можно вам не обращать внимания.
Возвращаясь в <a href="../C2/drawing/1_drawing_button/mainwindow.h" target="_blank">mainwindow.h</a>, видим, что наш класс <font color="purple">MainWindow</font> наследуется от <b><i>базового класса</i></b> <font color="purple">QMainWindow</font> (строчка "<tt>: <font color="olive">public</font> <font color="purple">QMainWindow</font></tt>") (который реализован в недрах Qt), а значит, наш класс <font color="purple">MainWindow</font> является, в том числе, классом <font color="purple">QMainWindow</font>, только ещё с расширениями и может использовать все его поля и методы (кроме <font color="olive">private</font>). И наш класс тоже помечает некоторые поля и методы как <font color="olive">public</font> (доступные кому угодно, даже <font color="navy">main</font>'у) или <font color="olive">private</font> (доступные только внутри методов класса).
Контрол <b>PushButton</b> тоже реализован соответствующим классом, находящимся в недрах библиотеки Qt. Туда нам лезть не особо надо, но можно пользоваться его публичными методами, например:
<tt><font color="maroon">ui</font>-&gt;pushButton-&gt;setText(<font color="green">"qwerty"</font>);</tt>
В файле <a href="../C2/drawing/1_drawing_button/main.cpp" target="_blank">main.cpp</a> происходит инициализация и запуск всего этого безобразия из функции <font color="navy">main</font>(), как ни странно.

<b>Qt Creator framework</b>
Теперь, как прописать реакцию на какое-либо событие? К сожалению, по двойному щелчку по кнопке в Дизайнере у нас не открывается Редактор кода со сгенерированным обработчиком события, как это было в старых добрых Delphi. Если действие довольно стандартное (например, клик по кнопке), то надо использовать механизм <b><i>сигналов</i></b> и <b><i>слотов</i></b>. Если не очень стандартное (например, изменение размеров <i>resize</i> или ручная прорисовка <i>paint</i>), то приходится перехватывать <font color="olive">protected</font> методы базовых классов, благо они все <i>виртуальные</i>.
<ol>
<li>Начнём с первого способа (открываем пример <b><a href="../C2/drawing/1_drawing_button" target="_blank">1_drawing_button</a></b>).
При нажатии на кнопке, её класс посылает <b><i>сигнал</i></b> <tt>clicked()</tt>. Но посылает не главному окну, не кому-нибудь конкретно, а широковещательно. Кто хочет, тот лови и обрабатывай. Это даёт возможность реализовывать связи не многие-ко-одному, а многие-ко-многим. За это приходится платить необходимостью прописывать связи вручную - функцией <b>connect</b>(<i>какой_объект_послал</i>, <i>какой_сигнал</i>, <i>какой_объект_поймал</i>, <i>в_какую_функцию</i>). Последний параметр, функция-обработчик, называется <b><i>слотом</i></b>. Поскольку ловит <b><i>сигнал</i></b> наш объект (<tt><font color="olive">this</font></tt>), то и реализовывать эту функцию мы должны в нашем классе <font color="purple">MainWindow</font> (так проще всего, хотя это не обязательно).
Объявляем наш метод-обработчик в <a href="../C2/drawing/1_drawing_button/mainwindow.h" target="_blank">mainwindow.h</a> в секции <tt><font color="olive">public slots</font>: </tt>, затем можно попросить QtCreator автоматически сгенерировать пустую реализацию этого интерфейса: щёлкаем по имени метода правой клавишей мыши (далее - <b><i>ПКМ</i></b>), выбираем <i>Рефакторинг -&gt; Добавить реализацию в <a href="../C2/drawing/1_drawing_button/mainwindow.cpp" target="_blank">mainwindow.cpp</a></i>, приступаем к программированию.
</li>
<li>Какое-то время поиграли в кубики, теперь наигрались. Отлично. Теперь, как что-либо начертить?
Всякими методами рисования (<tt>drawLine</tt>, <tt>drawText</tt> и др.) разработчики Qt решили не захламлять классы контролов, а вынести в т.н. <font color="purple">QPainter</font> - абстрактный контекст рисования, устройство рисования, канвас. При создании объекта этого класса надо указать в конструкторе, где мы будем рисовать: на форме, на экране, на кнопке, в буфере в памяти или ещё где-то. Пока указываем <tt><font color="olive">this</font></tt>, т.е. указатель на объект класса <font color="purple">MainWindow</font>. Но если указываем реальный контрол или окно, то абы когда рисовать нельзя будет - только при наступления события <i>paintEvent</i>.
Придётся обратиться во второму способу обработки событий - переопределению методов, в нашем случае это <i>paintEvent</i> (см. <b><a href="../C2/drawing/2_drawing_line" target="_blank">2_drawing_line</a></b>).
Пишем где-нибудь строчку "<tt><font color="olive">this</font>-&gt;<i>paintEvent</i>()</tt>", зажимаем Ctrl, подводим мышку, нас перебрасывают к тому месту в базовом классе, где она объявлена. Копируем сигнатуру метода, добавляем её в <a href="../C2/drawing/2_drawing_line/mainwindow.h" target="_blank">mainwindow.h</a>, добавляем реализацию вышеуказанным способом в <a href="../C2/drawing/2_drawing_line/mainwindow.cpp" target="_blank">mainwindow.cpp</a>, а написанную поделку "<tt><font color="olive">this</font>-&gt;<i>paintEvent</i>()</tt>" стираем.
Пробуем нарисовать прямую линию методом <tt>drawLine(x1, y1, x2, y2)</tt> из точки (x1, y1) в точку (x2, y2) и обнаруживаем, что координатная сетка у нас перевёрнута вверх ногами! Ось Oy смотрит вниз, что добавляет нам дополнительную головную боль. И это составляет, наверное, главную сложность в нашей задаче - не запутаться в преобразованиях координат. Но Oy смотрит вниз не только в Qt, а во всех графических библиотеках, что я видел. Что ж, придётся привыкать...
</li>
<li>Можно было, конечно, этим и ограничиться и тут и программировать рисование графиков. Но если уж физтех увлекается, его не остановить. :-)
Кроме того, прорисовывать две шкалы и вычислять 100500 значений функции заново при каждом чихе - это как-то нерационально и непрофессионально и может рассматриваться как недопустимое расточительство ресурсов, которые всегда ограниченные. Поэтому будем рисовать в памяти только один раз, а при событиях появления на экране, перекрытия другим окном, перемещения окна и т.д. - просто проецировать готовую картинку на экран. С учётом внутренних оптимизаций библиотеки, аппаратного ускорения графики и пр. и пр. - это намного эффективнее.
Открываем <b><a href="../C2/drawing/3_drawing_image" target="_blank">3_drawing_image</a></b> и методом пофайлового сравнения с предыдущими примерами (программами <b><u>diff</u></b>, <b><u>vimdiff</u></b>, <b><u>meld</u></b>, <b><u>TotalCommander</u></b>, да хоть чем угодно) видим, что я объединил оба примера и добавил приватное поле <tt><font color="purple">QImage</font> *<font color="maroon">image</font>;</tt> соответственно динамически создаю картинку-буфер в памяти в конструкторе и уничтожаю в деструкторе главной формы. По нажатию на кнопке я в ней рисую линию, а при запросе на прорисовку <i>paintEvent</i> просто печатаю её на форму.
</li>
<li>Дальше - больше. В <b><a href="../C2/drawing/4_drawing_paintWidget" target="_blank">4_drawing_paintWidget</a></b> я решил всю логику фокуса со внутренним графическим буфером выделить в отдельный компонент - виджет <b>PaintWidget</b>.
Как это сделать: в окошке <i>Проекты</i> щёлкаем по имени проекта ПКМ, <i>Добавить новый</i>, в появившемся диалоге уже должен быть выбран шаблон <i>C++ -&gt; Класс C++</i>. Пишем имя класса <tt><font color="purple">PaintWidget</font></tt> (будем внимательны, спросонья может получиться <font color="red"><s>PainWidget</s></font>, потом замучаетесь исправлять. :-) ), выбираем базовый класс <tt><font color="purple">QWidget</font></tt> (родительский класс всех контролов). Дальше всё туда переносим, как показано в <a href="../C2/drawing/4_drawing_paintWidget/paintwidget.cpp" target="_blank">примере</a>. Сам компонент <tt><font color="maroon">paintWidget</font></tt> тоже создаём/уничтожаем динамически в главном классе в <a href="../C2/drawing/4_drawing_paintWidget/mainwindow.cpp" target="_blank">mainwindow.cpp</a>.
Тут же я решил заодно обработать событие <i>resizeEvent</i> (хотя можно было его оставить до следующего примера <a href="../C2/drawing/5_drawing_layout" target="_blank">№5</a>). Поскольку цивилизованного способа изменить размер внутреннего буфера <tt><font color="purple">QImage</font> *<font color="maroon">image</font></tt> при изменении размера самого компонента <tt><font color="purple">PaintWidget</font> *<font color="maroon">paintWidget</font></tt> я не нашёл, то я просто удаляю старую картинку и пересоздаю новую с новыми размерами.
Разделения картинки и главного окна даёт следующие преимущества: управление размерами с помощью навешивания менеджера компоновки (о чём в <a href="../C2/drawing/5_drawing_layout" target="_blank">следующем примере</a>), а также отличение событий кликов по картинке от кликов по свободному месту на форме, событий перемещений мыши и т.д. Ну и вообще, это идеологически правильнее и в духе ООП: логическое выделение функциональности, разделение труда, инкапсуляция и много других красивых <s>непонятных</s> иностранных слов... :-)
</li>
<li><b><a href="../C2/drawing/5_drawing_layout" target="_blank">5_drawing_layout</a></b> - тут уже как-никак обрабатывается событие ресайзинга. В новомодных GUI-библиотеках принято не задавать вручную размеры и положение контролов на форме, а использовать менеджеры компоновки - <b>layout</b>. Да, они весьма своевольны и иногда считают себя умнее вас, поэтому к ним надо привыкнуть и научиться с ними совладать. Печали добавляет то, что в разных GUI-библиотеках (Qt, .NET, AWT, Swing, SWT, ...) лейауты очень похожи, однако всё время отличаются, так что легко запутаться.
Ну да ладно. Бросаем на форму в <i>Дизайнере</i> пару горизонтальных лейаутов, компонуем главное окно по вертикали, перебрасываем кнопку в нижний лейаут, прижимаем её пружинкой к краю. Вот с динамически создаваемым <tt><font color="maroon">paintWidget</font></tt>, который пытаемся запихнуть в верхний лейаут, придётся повозиться. Для того чтобы было, откуда брать образец, кидаем на форму временно какой-нибудь более-менее похожий компонент, переключаемся в редактор кода, удерживаем Ctrl и подводим мышку к полю <tt><font color="maroon">ui</font></tt>, оно нас перебрасывает, куда нужно, оттуда к <tt><font color="purple">Ui</font>::<font color="purple">MainWindow</font></tt>, оттуда переходим в <font color="purple"><u>ui_mainwindow.h</u></font> (если проект хоть раз уже компилировался), который полностью генерируется системой, и смотрим, что там творится с нашим временным компонентом. Берём за образец, копируем, а дальше применяя смекалку и документацию, задаём подходящие атрибуты для нашего динамического виджета.
</li>
<li><b><a href="../C2/drawing/drawing" target="_blank">drawing</a></b>
Тут я уже устал клепать новые проекты, поэтому дальше расширял один проект, но зато справлял код комментариями. А под конец даже на это не оставалось времени...
Главное, что вас здесь заинтересует, это функция 
<tt><font color="olive">void</font> <font color="purple">MainWindow</font>::draw_picture()</tt>
которая будет вызываться при каждом событии перерисовки картинки. Вдаваться в код этой функции необязательно. Все методы прорисовки вам уже должны быть известны.
Функция рисует две шкалы с учётом местоположения начала координат (<tt><font color="maroon">x0</font></tt>, <tt><font color="maroon">y0</font></tt>) и масштаба <tt><font color="maroon">scale</font></tt>. Если масштаб слишком мелкий, то частота прорисовки делений <tt>freqPoints</tt> уменьшается.
То же самое касается частоты появления цифр на шкале - <tt>freqNumbersX</tt> и <tt>freqNumbersY</tt>. Только для верности я определяю ширину очередной цифры таким образом:
<tt><font color="purple">QRect</font> bounds = painter.boundingRect(<font color="navy">0</font>, <font color="navy">0</font>, <font color="navy">0</font>, <font color="navy">0</font>, <font color="navy">0</font>, s);</tt>
и смотрю, не накладывается ли она на предыдущую цифру (для этого храню <tt>old_left</tt>, <tt>old_width</tt> и т.д.). Если накладывается, уменьшаю частоту.

<b>Сигналы</b>
Некоторые события, происходящие с <tt><font color="maroon">paintWidget</font></tt>, я просто перенаправляю в главное окно, ибо именно оно владеет всякими параметрами <tt><font color="maroon">x0</font></tt>, <tt><font color="maroon">y0</font></tt>, <tt><font color="maroon">scale</font></tt> и именно оно должно заниматься созданием картинки из примитивов. Для этого мне пришлось создавать свои сигналы (описывать их в секции <tt><font color="olive">signals</font>: </tt> в <a href="../C2/drawing/drawing/paintwidget.h" target="_blank">paintwidget.h</a> и вызывать с помощью ключевого слова <tt><font color="olive">emit</font></tt> (расширение библиотеки Qt) ). А затем ловить их в соответствующих слотах в классе главной формы.

Таким образом, обрабатываются следующие сообщения:
<ul>
<li><tt>paint_resized</tt> - ресайзинг - изменение размера - расширяется или обрезается график.
</li>
<li><tt>paint_double_clicked</tt> - по двойному клику изменяется положение начала координат, перемещается туда, где курсор.
</li>
<li><tt>paint_scrolled</tt> - масштабирование при скроллинге мышкой.
</li>
<li><tt>paint_mouse_move</tt> - отображение текущих координат в статус-баре в обычном состоянии и перетаскивание всего графика при захвате мышкой (флаг <tt><font color="maroon">captured</font></tt>).
</li>
<li><tt>paint_mouse_button_down</tt> и <tt>paint_mouse_button_up</tt> - всё ясно из названия: реализация захвата мышкой.
</li></ul></li></ol>
<b>TODO - Future plans</b>
Уф, пора, наконец, заканчивать эту длинную ночь.
Всё, что вам осталось сделать - в этот небольшой проект (250 строк только в главном модуле) добавить свои 15 строк, которые рисуют какую-нибудь функцию (sin(x) не предлагать!). При этом, разумеется, должны работать все вышеописанные фенечки (масштабирование, перемещение графика).
Находим строчку
<tt><font color="green">//TODO: Add your code here</font></tt>
удаляем паразитическую лишнюю линию, перечёркивающую график, и ... дальше сами.

<b>Использование динамической библиотеки <a href="../C2/drawing/drawing_release/calc.dll" target="_blank">calc.dll</a></b>
В своём <a href="../C2/drawing/drawing_release/drawing.exe" target="_blank">решении</a> этой задачи я реализовал использование библиотечки <a href="../C2/drawing/drawing_release/calc.dll" target="_blank">calc.dll</a>, которая вычисляет произвольные математические выражения (это моё решение задачи <b>calc1</b> из прошлого семестра + ещё некоторые расширения). Подключить её не очень сложно: в файле настроек проекта <a href="../C2/drawing/drawing/drawing.pro" target="_blank">drawing.pro</a> добавить строчку
<tt>LIBS += $$PWD/calc.dll</tt>
ну или полный путь к .dll-ке, если она лежит не в папке с проектом. Потом при запуске её надо ещё скопировать в папку, откуда запускается бинарник, например,
build-drawing-Desktop_Qt_5_3_MinGW_32bit-Debug
А в исходниках надо ещё добавить интерфейс функции:
<tt>extern "C" double <b>calc</b>(char *s, double x);</tt>
<ul>
<li>Поиграйтесь с моим <a href="../C2/drawing/drawing_release/drawing.exe" target="_blank">drawing.exe</a>, потестируйте его, попробуйте повводить разнообразные математические выражения (корректные!). Список поддерживаемых операций и функций здесь: <a href="../C2/drawing/drawing_release/operations.txt" target="_blank">operations.txt</a>. Обработку некорректных выражений я не реализовывал, обработку ОДЗ функций тоже - это я оставил вам. Но если для корректного выражения программа строит некорректный график - срочно пишите мне!
</li>
<li>Те, кто дойдёт до такого же уровня, как у <a href="../C2/drawing/drawing_release/drawing.exe" target="_blank">меня</a>, начав с уровня <a href="../C2/drawing/drawing" target="_blank">исходников</a>, получат +1 балл к зачёту. Кроме того, это будет серьёзная заявка на 10-ку.
</li></ul>

<b>Заключение</b>
Я надеюсь, вам это всё понравится. (Только не забывайте про обязательные наши задачи. А эта задача <font color="purple"><b>бонусная</b></font>, <font color="purple">опциональная</font>.) И что вы осилите. И что этот кратенький мануал вам когда-нибудь пригодится (пусть не сейчас, для первого раза это всё-таки сложно; так потом).

Have fun!

Желаю вам плодотворной работы!

Если у кого-то есть замечания/предложения/исправления/дополнения ©, я жду feedback'а.
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
