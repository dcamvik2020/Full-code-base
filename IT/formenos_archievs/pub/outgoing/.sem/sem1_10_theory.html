<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Семинар 10: Указатели, динамические массивы, сложные конструкции и аргументы командной строки - Теория</title>
</head>
<body>
<div style="white-space: pre-wrap;">
<ol>
<li>Начали с того, что продолжили жизненно важную тему <a href="sem1_10_pointers.html">Указатели</a>.
Ещё больше указателей, хороших и разных! Повторяем эту тему, перечитываем соответствующие главы Кернигана или другой книги, поскольку указатели отныне нам будут встречаться на каждом шагу. И как мы до сих пор жили без них?
Эта кратенькая справка вовсе не означает, что ею и надо ограничиться. Обязательно надо почитать ещё какую-нибудь книгу.
</li>
<li>На семинаре мы освоили <b>динамическое выделение памяти</b>, динамические переменные, динамические массивы. И теперь Валгринд станет вашим лучшим другом, который будет заботливо напоминать каждый раз, когда забудете написать <tt>free</tt>.
</li>
<li><b>Двумерные динамические массивы.</b> Яркий пример, зачем могут пригодиться двойные указатели.
<a href="../C1/pointers/dynarr2.c" target="_blank">dynarr2.c</a> и <a href="../C1/pointers/dynarr2.cpp" target="_blank">dynarr2.cpp</a> - реализация двумерных динамических массивов (массивов указателей) на Си и C++ соответственно. Можете использовать как шаблон/заготовку.
Вы должны уметь нарисовать схему выделения памяти под такие массивы (память выделяется для каждой строки <tt>A[i]</tt> массива <tt>A</tt> отдельно, эти куски памяти разбросаны по адресному пространству как попало, а чтобы связать их воедино {и в чёрную цепь сковать их}, используется дополнительный массив-связующее_звено - массив указателей на эти строчки - это как раз и есть двумерный динамический массив <tt>A</tt>).
</li>
<li>Мы научились укрощать следующих <b>крокодилов</b>:
<ol>
<li><tt><b>int *A[10];</b></tt> - массив из 10 указателей типа <tt>int *</tt>

Если размер массива неизвестен (например, при передаче в функцию как параметр), то объявление может быть таким: <tt><b>int *A[]</b></tt> или таким: <tt><b>int **A</b></tt> (эквивалентно).
А последнее определение может использоваться, если размер массива переменный (динамический массив указателей, в т.ч. двумерный динамический массив).
</li>
<li><tt><b>int (*A)[10];</b></tt> - указатель на массив из 10 <tt>int</tt>'ов

<tt>A + 1</tt> указывает на следующий массив из 10 <tt>int</tt>'ов и т.д. Поэтому такое объявление используется для двумерных динамических массивов, память под которые выделяется одним непрерывным блоком. Мы рассмотрим его на примере одной задачи на следующих семинарах.
Также такая конструкция может использоваться, если мы хотим обычный статический двумерный массив передать в функцию. Только в формальных параметрах функции <tt>int (*A)[10]</tt> может трансформироваться в <tt>int A[][10]</tt>, или <tt>int A[20][10]</tt>, или <tt>int A[0][10]</tt>, или <tt>int A[100500][10]</tt> - всё равно. Левую размерность многомерных статических массивов в формальных параметрах функции можно не указывать (поскольку передаётся всё равно только указатель), а остальные нужно (чтобы компилятор правильно высчитывал смещения в адресах при обращении к <tt>A[i][j]</tt>).

Вы должны уметь объяснить, в чём разница обращения к элементу двумерного массива <tt>A[i][j]</tt> в случае, если <tt>A</tt> - статический массив (один факт чтения ячейки памяти), и в случае, если он динамический (два факта чтения памяти, по цепочке).

Также осознайте и запомните соотношения для двумерных статических массивов:
<tt>&A == A == &A[0] == A[0] == &A[0][0]</tt>
и где это равенство нарушается для динамических массивов:
<tt>&A != A == &A[0] != A[0] == &A[0][0]</tt>
</li>
<li><tt><b>int (*func) (int a, int b);</b></tt> - указатель на функцию, принимающую 2 параметра и возвращающую <tt>int</tt>.
<ul>
<li>Собственно говоря, любое имя функции есть константный указатель на её начало (адрес первой ассемблерной инструкции функции), например, <tt><b><i>cmp_func</i></b></tt>, который мы передавали как последний параметр для <tt><b>qsort</b></tt>'а. А <tt><b><i>func</i></b></tt> - это вот неконстантный указатель.
</li>
<li>Пример:

<tt>int <b>add</b>(int a, int b) {
    return a + b;
}
int <b>sub</b>(int a, int b) {
    return a - b;
}
...
    int (*<b><i>func</i></b>) (int a, int b);
    <b><i>func</i></b> = <b>add</b>;
    c = <b><i>func</i></b>(7, 3); <font color="green">//вернёт 10</font>
    <b><i>func</i></b> = <b>sub</b>;
    c = <b><i>func</i></b>(7, 3); <font color="green">//вернёт 4</font></tt>
</li>
<li>Используется, например, для реализации функций обратного вызова - "callback".
</li>
<li>Ну, посмотрите <tt>man qsort</tt> , что написано в качестве последнего параметра. Теперь мы должны понимать, что это такое.
</li>
<li>Вот ещё примерчик:
<tt>void (*<b>set_new_handler</b>(void (*)()))();</tt>
С помощью
<tt>typedef void (*<b><i>new_handler</i></b>)();</tt>
это превращается... превращается... превращается... в <strike>элегантные шорты</strike>
<tt><b><i>new_handler</i></b> <b>set_new_handler</b>(<b><i>new_handler</i></b>);</tt>
</li>
<li>А вот почти то же самое, только в Линуксе (вы будете проходить это в 3-м семестре):
<tt>void (*<b>signal</b>(int signum, void (*<b><i>handler</i></b>)(int)))(int);</tt>

Собственно, последние две - это функции, которые принимают в параметрах указатели на другие функции (пользовательские, callback'и) и возвращают старое значение этих указателей.
</li></ul></li>
<li>Из таких указателей на функции (см. начало п. 3.3) можно, оказывается, конструировать целые массивы.
<b><tt>int (*func[10]) (int a, int b);</b></tt> - массив из 10 указателей на функции, которые принимают 2 параметра и возвращают <tt>int</tt>.
<tt><b>int (**func) (int a, int b);</b></tt> - а это то же самое, только массив динамический.

Используется такая радость для реализации событийной модели в ООП (высшая степень полиморфизма), когда куча слушателей (листенеров) подписываются на какое-то событие, и когда оно происходит, то уведомление рассылается всем листенерам, чтобы они на него как-то отреагировали.

<a href="../C1/pointers/listeners.c" target="_blank">listeners</a> - очень простой и урезанный пример использования этой конструкции.
</li>
<li>Ну и, чтобы совсем стало хорошо, вот вам занимательная <a href="http://habrahabr.ru/post/116255/" target="_blank">статья</a>, как справиться со всеми этими нагромождениями звёздочек и скобочек.
Почитайте, довольно интересно. В двух словах, надо взять таблицу приоритетов операций Си и аккуратно применять эти правила, последовательно разворачивая значки, начиная с идентификатора.
</li></ol>
РЕЗЮМЕ:
Вы должны уметь ЧИТАТЬ и ПОНИМАТЬ таких крокодилов. Но усердствовать в НАПИСАНИИ оных и пихать такое везде, где надо и не надо, не стоит, иначе ваш код сложно будет поддерживать и все будут плеваться в ваш адрес! Поэтому везде, где такое необходимо-таки использовать, обязательно ставить комментарии и упрощать такие конструкции с помощью <tt>typedef</tt>.
</li>
<li><b>Аргументы функции <tt>main</tt> и параметры командной строки.</b> Теперь, когда мы всё это прошли, мы знаем, что
<ul>
<li><tt><b>int main()</b></tt> - это функция с переменным числом параметров (в Си), и у неё может быть и такой интерфейс:
<tt>    int main(void);</tt>
и такой:
<tt>    int main(int argc, char *argv[]);</tt>
и такой:
<tt>    int main(int argc, char *argv[], char *envp[]);</tt>
Такие конструкции <tt>char *argv[]</tt> мы теперь тоже читать умеем и понимаем, что это массивы указателей на строки. В простонародье - массивы строк.
</li>
<li>Когда мы вызываем нашу программу из консоли (из командной строки) и передаём ей параметры, разделённые пробелами, например, так:
<tt>./my_prog.exe input.txt output.txt</tt>
то система делит эту командную строку на несколько Сишных строк, по пробелам:
<tt>"./my_prog.exe" "input.txt" "output.txt"
    argv[0]       argv[1]      argv[2]</tt>
собирает указатели на эти строчки в массив <tt>argv</tt> и передаёт в <tt>main</tt> вызываемой программы, по одному элементу массива на каждый параметр.
</li>
<li>А <tt>argc</tt> - это просто число элементов массива <tt>argv</tt>.
</li>
<li>Если какой-либо параметр сам по себе должен содержать пробелы, то чтобы он остался одним параметром и не разбивался лишний раз, мы сами должны заключить его в двойные кавычки прямо в командной строке:
<tt>my_prog.exe "C:\Program Files\Microsoft Visual Studio\Projects\my_prog\input.txt" output.txt</tt>
</li>
<li>Очень часто с помощью аргументов командной строки программе передаются имена файлов, которые она должна обработать.
Мы сталкиваемся с этим каждый день, и даже не замечаем этого, когда, например, открываем какой-нибудь mp3-файл с помощью Медиа-плеера. Или компилируем программу с помощью нашего любимого компилятора gcc (да хоть бы и Вижуал Студии):
<tt>gcc -Wall my_prog.c -o my_prog.exe</tt>
В данном случае в коде gcc, в его <tt>main</tt>'е будут:
<tt>argc = 5,
argv[0] = "gcc"
argv[1] = "-Wall"
argv[2] = "my_prog.c"
argv[3] = "-o"
argv[4] = "my_prog.exe"</tt>
Аргументы командной строки будут во многих Индивидуальных Задачах на зачёте.
</li>
<li>В массив <tt>envp</tt> попадают системные переменные окружения в формате "KEY=value". Например:
<tt>USER=Andrey
HOME=/home/andrey
PATH=C:\Windows;C:\Windows\system32</tt>    (эта особенная переменная содержит набор каталогов, в которых будет выполняться поиск исполняемых файлов, если к ним не указан полный абсолютный путь. В Винде каталоги разделяются ';' а в Линухе ':' ).
Эти переменные задаёт операционная система для каждой запускаемой программы.
</li></ul></li></ol>
Да, получилось много материала. Но я старался расписать всё поподробнее. Надеюсь, вы это осилите.
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
