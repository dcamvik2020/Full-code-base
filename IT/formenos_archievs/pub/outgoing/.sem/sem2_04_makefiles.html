<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Семинар 4: Makefiles</title>
</head>
<body>
<div style="white-space: pre-wrap;">
Что же такое мейкфайлы и с чем их едят? Чем же они лучше простых скриптов (списков команд в файлах .bat или .sh)? Тем, что если у нас в проекте 100500 модулей, компиляция которых может затягиваться на многие часы, то после очередной модификации какого-то (каких-то) модуля не придётся перекомпилировать все 100499 исходников, а умная магическая утилита <tt>make</tt> пройдётся по всем зависимостям и, если дата модификации одноимённого файла позже, чем дата модификации файла-цели (либо последнего вообще нет), то выполнит соответствующие команды. Далее, рекурсивно обработает все цели, которые зависят от только что выполненной. Т.о., пересоберутся только те модули, которые нужно пересобрать (которые прямо или косвенно зависят от изменённых файлов), и итоговый исполняемый файл. Если вообще ничего не менялось, то процесс компиляции завершится совсем быстро.

Если в двух словах и не рассматривая всякие доп.плюшки, то синтаксис такой:
<tt>Цель<sub>1</sub>: Зависимость<sub>1</sub><sup>1</sup> Зависимость<sub>1</sub><sup>2</sup> ... Зависимость<sub>1</sub><sup>N</sup>
	Команда<sub>1</sub><sup>1</sup>
	...
	Команда<sub>1</sub><sup>M</sup>

Цель<sub>2</sub>: Зависимость<sub>2</sub><sup>1</sup> Зависимость<sub>2</sub><sup>2</sup> ... Зависимость<sub>2</sub><sup>K</sup>
	Команда<sub>2</sub><sup>1</sup>
	...
	Команда<sub>2</sub><sup>L</sup></tt>
и т.д.
где <tt>Зависимость<sub>I</sub><sup>J</sup></tt> тоже может выступать в качестве <tt>Цели</tt>, которая чаще всего также является именем файла.
<b>! Перед <tt>Командами<sub>I</sub><sup>J</sup></tt> обязаны стоять <u>TAB'ы</u>. Не пробелы.</b>
Первая в Makefile цель - цель по умолчанию. Ещё часто встречается цель "<tt>all</tt>" - обычно туда складываются зависимости от всех исполняемых файлов.
Если имя мейкфайла "<tt>Makefile</tt>", то достаточно выполнить просто команду "<tt>make</tt>". Если нет, то надо указать имя файла (обычно с ключом -f, например, "<tt>make -f makefile6</tt>")
Т.е. если в консоли пишем просто "<tt>make</tt>", то утилита make ищет файл с именем <tt>Makefile</tt> (или <tt>makefile</tt>) и выполняет первую цель (и все зависимые). Если указываем цель ("<tt>make Цель2</tt>"), то начнёт с неё.

Вот <a href="../C2/prog/LinuxGCC/Makefiles" target="_blank">сюда</a> я выложил сборник разных вариантов мейкфайлов - тут два модуля исходного кода, объединены они одним хедером. Там приведены примеры, какие в мейкфайлах можно использовать шаблоны (например, <tt>$&lt;</tt> вместо имени первой зависимости) и прочие сокращения (например, <tt>cc $&lt; -c</tt> в качестве команды по умолчанию и <tt>.c.o</tt> в качестве правила по умолчанию).

Теперь подробнее прокомментирую каждый мейкфайл.
<ol>
<li>Makefile1: я в зависимости для <tt>prog</tt> и <tt>unit</tt> добавил и <tt>header.h</tt>, хотя он и не указан в команде компиляции. Сделано это для того, чтобы если в хедере изменилась какая-нибудь константа/макрос/тип, а .c-файл не поменялся, то модули и проект всё равно были бы пересобраны.
<a href="../C2/prog/LinuxGCC/Makefile" target="_blank">Makefile1</a>:
<tt>prog: prog.o unit.o
	gcc prog.o unit.o -o prog
prog.o: prog.c header.h
	gcc -c prog.c
unit.o: unit.c header.h
	gcc -c unit.c</tt>
</li>
<li>Далее, для удобства переноса/переписывания мейкфайлов из одного проекта в другой, начнём их упрощать, исключая/минимизируя захардкоженные имена файлов. Для этого нам пригодятся специальные мета-символы, смотрим, например, <a href="http://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html#Automatic-Variables" target="_blank">сюда</a>:
<tt>$&lt;</tt> означает имя исходного файла (первой <tt>Зависимости<sup>1</sup></tt>). Годно во всех компиляторах.
<tt>$^</tt> - все Зависимости, перечисленные через пробел. (GNU only.)
<tt>$@</tt> - имя выходного файла (<tt>Цели</tt>). Обозначения уже зависят от компилятора.
<a href="../C2/prog/LinuxGCC/Makefiles/Makefile2" target="_blank">Makefile2</a>:
<tt>prog: prog.o unit.o
	gcc $^ -o $@
prog.o: prog.c header.h
	gcc -c $&lt;
unit.o: unit.c header.h
	gcc -c $&lt;</tt>
</li>
<li>В GCC можно ещё использовать что-то типа шаблонов файлов (с символом <tt>%</tt> в качестве джокера в линухе, и <tt>$*</tt> в винде). Все найденные в папке файлы, подходящие под данный шаблон, будут обработаны, как полагается.
<a href="../C2/prog/LinuxGCC/Makefiles/Makefile3" target="_blank">Makefile3</a>:
<tt>%.o: %.c header.h
	gcc -c $&lt;</tt>
</li>
<li>Если шаблоны не поддерживаются, то не беда, ведь есть ещё суффиксные правила вида <tt>.FROM.TO</tt>, где <tt>from</tt> и <tt>to</tt> - расширения файлов.
Увы, в этом случае зависимостью от хедеров придётся пожертвовать.
<a href="../C2/prog/LinuxGCC/Makefiles/Makefile4" target="_blank">Makefile4</a>:
<tt>.c.o:
	gcc -c $&lt;</tt>
</li>
<li><a href="../C2/prog/LinuxGCC/Makefiles/Makefile5" target="_blank">Makefile5</a>:
Продолжаем издеваться над нашим мейкфайлом. Если команда компиляции не указана вовсе, то она полагается равной <tt>cc -c $&lt;</tt> ("команда по умолчанию"), а <tt>cc</tt> - это симлинк обычно на <tt>gcc</tt> в линухе. Пишем просто:
<tt>.c.o:</tt>
</li>
<li><a href="../C2/prog/LinuxGCC/Makefiles/Makefile6" target="_blank">Makefile6</a>:
Можно пойти ещё дальше и вообще отказаться от секции для компиляции модулей. Правило по умолчанию есть "<tt>.c.o:</tt>". Такое прокатило и в вижуале.
Насчёт сборки .cpp-файлов последним способом уже не уверен.
</li>
</ol>
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
