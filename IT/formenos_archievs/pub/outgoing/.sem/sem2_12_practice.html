<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Семинар 12: Мега-задача и Ассемблер в Visual Studio и GCC - Практика</title>
</head>
<body>
<div style="white-space: pre-wrap;">
<ul>
<li><b>Мега-задача:</b>
<ul>
<li><a href="../C2/mega625.c" target="_blank">mega625.c</a> - мой вариант мега-задачи на Си. Обратите внимание, что я разбил решение задачи на 4 обязательные функции (<tt><b>check</b>()</tt>, <tt><b>rule1</b>()</tt>, <tt><b>rule2</b>()</tt> и <tt><b>test</b>()</tt>), от вас буду требовать того же самого. Также обратите внимание на то, что в <tt><b>rule2</b>()</tt> я обошёлся без <tt>O(n^2)</tt> и дополнительной памяти, зависящей от <tt>n</tt><!--, а сделал вообще за один цикл, за один проход по строке-->. Поэтому сначала сделайте вариант на Си, чтобы я одобрил алгоритм, а потом уже портируйте на ассемблер.
</li>
<li><a href="../Assembler/Windows/NASM32/Programs_libc/mega625.asm" target="_blank">mega625.asm</a> - мой вариант мега-задачи на Ассемблере. Обратите внимание, что строку <tt>buf</tt> как глобальную переменную может использовать только <tt><b>main</b></tt>, а все остальные функции должны получать её через параметры.
</li></ul></li>
<li><b>Детерминант</b>, 3-й способ вычисления (с помощью алгоритма эффективной генерации перестановок):
<ul>
<li><a href="../C2/determinant_v3_old.c" target="_blank">determinant_v3_old</a> - вычисление детерминанта по формуле полного разложения, ровно по определению.
</li>
<li><a href="../C2/determinant_v3.c" target="_blank">determinant_v3</a> - оптимизированный вариант предыдущей задачи, число нарушений порядка НЕ считается отдельно, а встроено в алгоритм генерации перестановок. На небольших матрицах может работать даже быстрее, чем Гаусс. На больших всё становится резко хуже.
</li></ul></li>
<li><a href="../C2/inline_asm" target="_blank">inline_asm</a> - <b>ассемблерные вставки:</b>
<ul>
<li><a href="../C2/inline_asm/asm_visual.c" target="_blank">asm_visual</a> - простейшая ассемблерная вставка в Visual Studio и компиляторах Borland (и иже с ними).
</li>
<li><a href="../C2/inline_asm/asm_visual_call.c" target="_blank">asm_visual_call</a> - то же самое, плюс реализация маленькой процедурки в ассемблерной вставке.
</li>
<li><a href="../C2/inline_asm/asm_att.c" target="_blank">asm_att</a> - простейшая ассемблерная вставка в компиляторах GCC (Linux/MinGW), синтаксис AT&T. Сюда включается наш любимый QtCreator, Code::Blocks, Eclipse, Dev-Cpp, ... Переменные можно использовать только глобальные.
</li>
<li><a href="../C2/inline_asm/asm_intel.c" target="_blank">asm_intel</a> - то же самое, только синтаксис Intel.
</li>
<li><a href="../C2/inline_asm/asm_att_extended.c" target="_blank">asm_att_extended</a> - расширенная форма ассемблерной вставки (с секциями input, output и clobber), используется в т.ч. для доступа к локальным переменным Си.
</li></ul>
Подробнее, кому интересно, см. в <a href="sem2_12_theory.html">теории</a>.
</li>
<li><b>Intel vs AT&T синтаксис в GNU ассемблере</b> (GAS). Есть пару примерчиков на этом ассемблере:
<ul>
<li><a href="../Assembler/Linux/GAS32/ATT/Programs_Pure" target="_blank">AT&T 32 bit</a>
</li>
<li><a href="../Assembler/Linux/GAS32/Intel/Programs_Pure" target="_blank">Intel 32 bit</a>
</li>
<li><a href="../Assembler/Linux/GAS64/ATT/Programs_Pure" target="_blank">AT&T 64 bit</a>
</li>
<li><a href="../Assembler/Linux/GAS64/Intel/Programs_Pure" target="_blank">Intel 64 bit</a>
</li></ul>
Там не всё, только то, что успеваю портировать.
</li>
<li>Как открывать дизассемблерный листинг в процессе пошаговой отладки Сишной проги в IDE и как из Сишного файла получить ассемблерный листинг, я вам показывал на семинаре, это вы должны уметь.
</li>
</ul>
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
