<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Семинар 10: Указатели</title>
</head>
<body>
<div style="white-space: pre-wrap;">
<ul>
<li><b>Указатель</b> - это переменная, содержащая адрес. Адрес другой переменной, адрес массива, структуры или его/её части, адрес выделенного куска памяти, адрес машинной инструкции, библиотеки... просто какой-то левый адрес, даже если по нему нельзя писать или/и читать.
</li>
<li>Указатели применяются для косвенного доступа к переменным или другим данным. Иногда обратиться к переменной по её имени не представляется возможным (в т.ч. из-за ограничения области видимости - например, когда она объявлена в другой функции), в этом случае можно попытаться добраться до неё по адресам, с помощью указателей и адресной арифметики. Или переменная/объект вовсе не имеет имени - когда память под него была выделена динамически. Есть и другие случаи применения указателей: например, строки, списки, деревья, графы в Си построены на указателях. Ну и более специфические случаи.
</li>
<li><b>Размер</b> переменной-указателя равен размеру машинного слова (4 байта в 32-битных системах, 8 байт в 64-битных, 2 байта в 16-битных (если near-указатели)).
</li>
<li><b>Синтаксис:</b>
<tt>	type *name;</tt>
где <tt>type</tt> - имя типа переменной, на которую указывает указатель. Если описывается сразу несколько указателей, то надо перед каждым ставить звёздочку:
<tt>	int *p1, *p2;</tt>
иначе мы опишем один указатель и одну целую переменную (именно поэтому принято пробел ставить перед *, а не после, как было бы логичнее; но компилятору всё равно, хоть вообще без пробелов).
</li>
<li>Указатель можно "настроить" на какую-нибудь переменную с помощью операции взятия адреса "&":
<tt>	int a = 5;
	int *p = &a; <font color="green">// можно и разделить описание и инициализацию:</font> int *p; p = &a;</tt>
и затем с помощью операции разыменования указателя * читать или писать значение из/в переменную a:
<tt>	*p = 6; <font color="green">// теперь a == 6</font>
	a = 7;
	printf(<font color="green">"%d "</font>, *p); <font color="green">// 7</font>
	*p = *p + 3;
	printf(<font color="green">"%d "</font>, *p); <font color="green">// 10</font></tt>
Т.е. "<tt>a</tt>" и "<tt>*p</tt>" отныне синонимы, и где можно использовать одно, можно использовать и другое, в т.ч. в математических операциях, операторах и функциях ввода-вывода, и т.д.
Но указатель можно и "перенастроить" на другую переменную:
<tt>	int b = 21;
	p = &b;
	printf(<font color="green">"%d "</font>, *p); <font color="green">// 21</font></tt>
</li>
<li>Значение указателя определяет начало куска памяти, с которым идёт работа (левую границу ячейки памяти), а тип, который стоит слева от звёздочки - размер этого куска (а следовательно, и правую границу ячейки памяти).
Пусть далее все указатели имеют значение 0x402000 (16-чное число), а по этому адресу хранятся данные:
<tt>	0x402000: F7 E6 D5 C4 B3 A2 91 80</tt>
Обратите внимание, что в архитектурах little-endian, к коим относится Intel'овская x86, байты в памяти располагаются в обратном порядке.
<tt>	int *pi;
	long long *pl;
	char *pc;</tt>
Пусть все эти указатели указывают на байтик со значением F7.
Тогда <tt>*pi</tt> будет равно <tt>0xC4D5E6F7, *pl == 0x8091A2B3C4D5E6F7, *pc == 0xF7</tt>.
</li>
<li>Для указателей, кроме взятия адреса & и разыменования * , определены следующие операции:
<ol>
<li>Сложение указателя с целым числом.
<tt>	int *q = pi + 1;</tt>
<tt>q</tt> будет указывать на следующую за <tt>pi</tt> ячейку памяти, а поскольку она размером 4 байта (размер <tt>int</tt>'а), то численно <tt>q</tt> будет равняться <tt>0x4020004</tt>, а <tt>*q</tt> будет равно <tt>0x8091A2B3</tt>.
<tt>	q++; <font color="green">// теперь q будет равняться 0x4020008.</font></tt>
<tt>pl + 2</tt> будет равняться <tt>0x402010</tt>. А <tt>pc + 3 == 0x402003</tt>.
И вообще, при сложении указателя <tt>type *p;</tt> с целым числом <tt>k</tt> выражение <tt>p + k</tt> численно равно <tt>p + k * <b>sizeof</b>(type)</tt>.
</li>
<li>Разность указателя и целого числа. Ну, думаю, тут всё понятно. <tt>int</tt> - знаковый тип.
<tt>	int *z = pi - 1; <font color="green">// будет численно равно 0x401FFC.</font></tt>
</li>
<li>Разность двух указателей.
<tt>	int d = q - z; <font color="green">// равна 3</font></tt>
На выходе имеем тип целое число, численно равное <tt>(p2-p1)/<b>sizeof</b>(type) = (q-z)/<b>sizeof</b>(int)</tt>. Т.е. разность измеряется в количестве ячеек памяти определённого размера.
Обратите внимание: если вычитаем указатели на <tt>long</tt> или на <tt>char</tt> или на ещё что-нибудь, то всё равно получаем <tt>int</tt>.
Думаю, понятно, зачем это ввели: для симметрии со сложением указателя с числом, для полноты адресной арифметики, чтобы не было сюрпризов в сложных выражениях.
</li></ol>
И ещё: другие операции для указателей не определены. Мы не имеем права сравнивать указатели так:
<tt>	<s>if (p1 &gt; p2)</s> <font color="green">// если ваш компилятор такое позволяет, ждите беды (UB)</font></tt>
но зато вот так OK:
<tt>	if (p1 - p2 &gt; 0)</tt>
Складывать указатель с указателем, понятное дело, тоже нельзя, т.к. на выходе получаем бред.
</li>
<li><b>Спецификатор <tt>const</tt>.</b>
<ol>
<li><tt>	const int *p; <font color="green">// указатель на константу</font></tt>
Можем делать вот так:
<tt>	int A[] = {1, 3, 5};
	p = &A[0];</tt>
и
<tt>	p++;
	printf(<font color="green">"%d\n"</font>, *p); <font color="green">// 3</font></tt>
<font color="red">но не можем так:</font>
<tt>	<s>*p = 7;</s>

	int const *p; <font color="green">// то же самое, что и const int *p;</font>

	const char *s = <font color="green">"Hello"</font>;</tt>
Думаю, часто встречали этого гостя. Указатель на строковую константу, т.е. на константу типа <tt>char</tt> и заодно на всю цепочку символов, что следует за ним, до завершающего нуля.
</li>
<li><tt>	int * const p = &A[0]; <font color="green">// константный указатель</font></tt>
Должны его сразу же инициализировать, иначе потом не получится:
<tt>	<s>p = &A[0];</s> <font color="red">// запрещено</font>
	<s>p++;</s> <font color="red">// запрещено</font></tt>
Зато изменять содержимое вполне законно:
<tt>	*p = 10; <font color="green">// A[] == {10, 3, 5};</font></tt>
</li>
<li><tt>	const int * const p = &a;</tt>
Ну с таким могучим указателем мы уже ничего поделать не сможем. Только на чтение.
</li></ol></li>
<li><b>Соотношения между указателями и массивами.</b>
<tt>	int A[] = {1, 3, 5};</tt>
Имя массива является адресом - константным указателем - на его нулевой элемент и численно равно <tt>&A[0]</tt>. Т.е. во всяких там приведениях типов и арифметических операциях <tt>A</tt> имеет тип <tt>int * const</tt>.
Из всех приведённых выше примеров уже должно быть понятно, что <tt>A+1</tt> указывает на первый элемент, равный 3, <tt>A+2</tt> на 5-ку.
И вообще, высекаем в граните силиконовую формулу:
<tt>	<b>A + i == &A[i]</b></tt>
Действует она в обе стороны. И даже более того, применяем к обеим частям операцию разыменовывания * , получаем вторую кремниевую формулу:
<tt>	<b>*(A+i) == A[i]</b></tt>
Ну или, пользуясь коммутативностью сложения и убийственным остроумием создателей языка Си,
<tt>	... == *(i+A) == i[A]</tt>
</li>
<li>Указатели бывают <b>типизированные</b> и <b>нетипизированные</b>. Типизированные - это все, что мы видели до этого.
Нетипизированный указатель один:
<tt>	void *p;</tt>
Предназначен для хранения адреса и ничего более. Мы не сможем по нему ни считать, ни записать (ибо непонятно, сколько байт по этому адресу читать/писать), к нему неприменима адресная арифметика. И единственное, что с ним можно сделать - привести к типизированному указателю:
<tt>	pi = (int *) p; <font color="green">// где pi есть int *</font></tt>
Для Си приведение типов здесь необязательное, а для C++ обязательное. Поэтому для нас всегда и везде обязательное, поэтому и при динамическом выделении памяти
<tt>	int *A = (int *) malloc(n * sizeof(int));</tt>
явное приведение типа я буду просить указывать, т.к. у <tt>malloc</tt>'а тип возвращаемого значения <tt>void *</tt> .
</li>
<li><b>Указатель на структуру.</b>
<tt>	Student *p_stud = ...;</tt>
Ничего нового. При инкременте <tt>p_stud</tt> он численно будет прыгать не на 1, не на 4, а на <tt><b>sizeof</b>(Student)</tt> байт.
<!--Единственное, что я забыл / не успел сказать на семинаре - это -->Как получать доступ к полям в этом случае.
Вот так я писать <b>НЕ</b> рекомендую:
<tt>	(*p_stud).age = 18; <font color="green">// обратите внимание на скобочки - приоритет операций</font></tt>
потому что уже давно специально для этого изобрели операцию "стрелочка":
<tt>	p_stud-&gt;age = 18;</tt>
Т.е. <tt>p_stud-&gt;age</tt> эквивалентно <tt>(*p_stud).age</tt> .
Другими словами: для получения доступа к полю структуры
"." применяется, когда слева от неё стоит структура, а
"-&gt;" применяется, когда слева от неё стоит УКАЗАТЕЛЬ на структуру.
</li>
</ul>
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
