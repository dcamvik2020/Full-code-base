<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Урок 11: Превращаем C/C++ в Паскаль @ AdvancedMagic</title>
</head>
<body>
<div style="white-space: pre-wrap;">
Ну что же, продолжаем нашу псевдопостоянную рубрику "Для тех, кто думает, что знает Си".
И сегодня мы разберёмся, чем же язык Си (и C++) хуже, чем старый добрый тёплый ламповый школьный Паскаль.
<ol>
<li>Вы, конечно, знаете, что в языке C++ есть тип <tt><b>bool</b></tt>, который принимает значения <tt><b>true</b></tt> или <tt><b>false</b></tt> (всё это ключевые слова и именно в таком регистре), а в языке C то же самое можно сэмулировать с помощью <tt>define</tt>'в:

<tt>#define bool int
#define true 1
#define false 0
#define begin {
#define end }</tt>

или подключить какой-нибудь <a href="../C1/pseudo_pascal/pascal.h" target="_blank">заголовочный файл</a>, в котором это уже сделано. Но это ещё не всё. Таким образом можно переписать пол-Паскаля.
Многие, пришедшие с этого замечательного языка, разочарованы, что приходится писать "<tt>&&</tt>" вместо "<tt>and</tt>", "<tt>||</tt>" вместо "<tt>or</tt>" и т.д. Но так было не всегда. Не у всех же есть на клавиатуре символы '<tt>&</tt>' и '<tt>|</tt>' '<tt>!</tt>' Поэтому в язык C++ ввели <b><i>алиасы</i></b> - ключевые слова-заменители <tt>and</tt>, <tt>or</tt>, <tt>not</tt> и некоторые другие, которые есть то же самое, что и <tt>&&</tt>, <tt>||</tt>, <tt>!</tt> соответственно. И всё это время можно было использовать такие читабельные варианты вместо значков, с момента принятия Стандарта C++ в 98 году, но почему-то мало кто об этом знает. Быть может, потому, что гиганты индустрии Microsoft и Borland решили не имплементировать это положение Стандарта (правда в M$ Visual C++ можно подать ключ <tt>/Za (Disable Language Extensions)</tt>, и тогда оно заработает). Но зато GCC (и его порт под Windows - MinGW) поддерживают ключевые слова <tt>and</tt>, <tt>or</tt>, <tt>not</tt>, но только в C++. А в чистом Си можно обойтись опять же <tt>define</tt>'ми или подключить хедер &lt;iso646.h&gt;.
</li>
<li>Хорошо, скажут ценители Паскаля. Но как же быть со вложенными функциями? Их-то нету ни в Стандартах Си, ни в Стандартах C++! Да, это так. Но GCC реализует не только все капризы Стандарта, но ещё и много всякой отсебятины (называемой расширениями GCC, <i>GCC extensions</i>), которая к тому же ещё и включена по умолчанию. И одно из расширений - это вложенные функции. Т.е. такой примерчик вполне работает (см.программу <a href="../C2/adv/nested.c" target="_blank">nested.c</a>):

<tt>#include &lt;stdio.h&gt;

int main(void) {
	int i, n, A[100];
	int sumX(int m) {
		int i, res = 0;
		for (i = m; i &lt; n; i++)
			res += A[i];
		return res;
	}
	scanf(<font color="green">"%d"</font>, &n);
	for (i = 0; i &lt; n; i++)
		scanf(<font color="green">"%d"</font>, A + i);
	printf(<font color="green">"%d\n"</font>, sumX(3));
	return 0;
}</tt>

Функция <tt><b>sumX</b>()</tt>, вложенная в функцию <tt><b>main</b>()</tt> (можно было взять и любую другую), использует, кроме своих локальных переменных и параметров, ещё и локальные переменные внешней функции <tt><b>main</b>()</tt>.
Но такое работает, наоборот, только в чистом Си, но не работает в C++. В C++, если очень надо, можно это дело завернуть в класс.
Вот такой получился Паскаль в исполнении C/C++, хоть и половинчатый. Либо одно работает, либо другое, что в C, что в C++.
Надо ли говорить, что в M$ Visual и Borland C++ Builder такое будет вне закона и ни за что не заработает?
</li>
<li>Но и это ещё не всё. Наши любимые скобочки <tt>{</tt> и <tt>}</tt> можно не только улучшить с помощью "<tt>#define begin {</tt>" и "<tt>#define end }</tt>", но и испортить.
Вы все, конечно, знаете, что такое <a href="https://ru.wikipedia.org/wiki/Диграф_(языки_Си)" target="_blank">диграфы</a> и <a href="https://ru.wikipedia.org/wiki/Триграф_(языки_Си)" target="_blank">триграфы</a>. Это сделали для тех несчастных людей, у которых были ущербные клавиатуры, которые не имели некоторых символов, и поэтому их решили заменить комбинациями других символов. И так это и тянется с тех незапамятных времён прошлого века, и, к сожалению, в Стандарте до сих пор содержится эта дрянь.
Скобочки <tt>&lt;%</tt> и <tt>%&gt;</tt> поддерживаются и в GCC/MinGW, и в Borland C++. А M$ Visual опять в пролёте.
Если вы покажете своим товарищам следующую программку (<a href="../C2/adv/andor.cpp" target="_blank">andor.cpp</a>):

<tt>#include &lt;stdio.h&gt;

int main(void)
&lt;%
	char c = getchar();
	if (((c &gt;= <font color="green">'a'</font>) and (c &lt;= <font color="green">'z'</font>)) or ((c &gt;= <font color="green">'A'</font>) and (c &lt;= <font color="green">'Z'</font>)))
	&lt;%
		printf(<font color="green">"Literal\n"</font>);
	%&gt;
	return 0;
%&gt;</tt>

они, наверняка, возмутятся и скажут: "Это какой вообще язык?"
Есть даже такое направление в программировании - называется "<a href="https://ru.wikipedia.org/wiki/Обфускация_(программное_обеспечение)" target="_blank">обфускация</a>". Например, если вы по условиями лицензии GNU обязаны раскрыть свой исходный код, но не хотите, чтобы враг полакомился им, вы можете так извратить его до неузнаваемости, что не только сам чёрт ногу сломит, но и мама родная не узнает.

Что ж. Язык Си как острая бритва: с его помощью можно сделать как изящное произведение искусства, так и кровавое месиво. © Керниган
</li>
</ol>
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
