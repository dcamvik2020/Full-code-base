<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Семинар 3: Представление вещественных чисел в ЭВМ - Теория</title>
</head>
<body>
<div style="white-space: pre-wrap;">
Для облегчения понимания, я вам написал небольшое пояснение, как хранятся десятичные дроби в памяти машины. Это поможет вам на контрольной, так как будут соответствующие задачи.

В современных ЭВМ вещественные числа представляются как числа с плавающей точкой (так достигается бОльшая точность по сравнению с числами с фиксированной точкой; легче хранить очень большие и очень маленькие числа). При этом двоичные дроби приводятся к нормализованной форме,
т.е. вида <tt>±mE(±p)</tt>, где <tt>m</tt> - мантисса, число <tt>1 &le; m &lt; 10</tt> (в двоичной СС), а <tt>p</tt> - порядок.
Эта запись означает <tt>±m * 2<sup>(±p)</sup></tt> (если рассматриваются двоичные числа).
В зависимости от того, какой тип данных нам нужен (<b><u>короткий</u></b>, <b><u>длинный</u></b> или <b><u>расширенный</u></b>), выбираем, сколько бит у нас отводится на мантиссу и сколько на порядок.
Тут очень удобно воспользоваться таблицей из <a href="../Korotin_2010/Лекция 1.ppsx" target="_blank">1-й презентации Коротина</a>, слайда 41.
<ul>
<li>Ну, например, нам надо представить в <b><u>коротком</u></b> виде число <b>6.7</b>.
<ol>
<li>Для начала переводим его в двоичную дробь
(отдельно целую часть 6<sub>10</sub> = 110<sub>2</sub>, отдельно дробную по известному алгоритму:
0.7 * 2 = <u>1</u>.4  - выписываем в ответ целую часть, т.е. 1, а дробную продолжаем умножать на 2
0.4 * 2 = <u>0</u>.8  - дописываем в ответ 0
0.8 * 2 = <u>1</u>.6
0.6 * 2 = <u>1</u>.2
0.2 * 2 = <u>0</u>.4
0.4 * 2 = <u>0</u>.8
0.8 * 2 = <u>1</u>.6  - зациклились...
выписывая целые части результатов, получаем, что 6.7<sub>10</sub> = 110.10110(0110)<sub>2</sub> )
</li>
<li>Теперь приводим это число к <b><i>нормализованной</i></b> форме (т.е. сдвигаем точку к старшей единичке): 110.10110(0110)<sub>2</sub> = 1.1010110(0110)<sub>2</sub>E10<sub>2</sub> (здесь 10<sub>2</sub>, стоящая после E - тоже в двоичном виде, т.е. это попросту 2<sub>10</sub>).
</li>
<li>В <b><u>коротком</u></b> представлении (ему соответствует Сишный тип float, 4 байт) под порядок отводится <b><u>8</u></b> бит, 1 бит под знак числа, всё остальное (<b><u>23</u></b> бита) - под мантиссу.
</li>
<li>Далее. Порядок во всех трёх представлениях записывается в <b><i>смещённом</i></b> виде, т.е.
число 0 записывается как 0111...11,
число 1 как 1000...00,
число 2 как 1000...01,
число -1 как 0111...10,
число -2 как 0111...01, и т.д.
Т.е. отталкиваемся от нуля (0111...11) и вычисляем, как кодируется данный порядок.
В нашем примере получается 1000...01.
</li>
<li>После битов порядка следом записываются биты мантиссы, причём лидирующие "1." не учитываются (старший бит в нормализованном виде всегда равен 1, поэтому на нём экономят).
</li></ol>
Резюмируя всё вышесказанное, записываем число <b>6.7<sub>10</sub></b> в двоичном виде с плавающей точкой в <b><u>коротком</u></b> представлении так:
<tt>
знак / порядок / мантисса
    0100 0000 1101 0110 0110 ...          - в  2-чном виде.
      4    0    D    6    6    6  6  6    - в 16-чном виде.</tt>
Именно это мы и увидим в отладчике-дизассемблере, если для кода   <tt>float f; scanf("%f", &f);</tt>   введём число 6.7.
</li>
<li>Далее. Для <b><u>длинного</u></b> представления (тип double, 8 байт) под порядок выделяется <b><u>11</u></b> бит, под мантиссу <b><u>52</u></b> бита.
<tt>
знак /  порядок   / мантисса
    0100 0000 0001 1010 1100 1100 ...             - в  2-чном виде.
      4    0    1    A    C    C  C  C  CCCCCCCD  - в 16-чном виде.</tt>
Последняя тетрада получила значение на 1 больше из-за округления.
</li>
<li>Наконец, для <b><u>расширенного</u></b> представления (тип long double, 10 байт) под порядок выделяется <b><u>15</u></b> бит, под мантиссу <b><u>64</u></b>.
Только для этого типа старший бит мантиссы "1." <b><u>не</u></b> отбрасывается.
<tt>
знак /    порядок      / мантисса
    0100 0000 0000 0001 1101 0110 0110 ...              - в  2-чном виде.
      4    0    0    1    D    6    6  6  666666666666  - в 16-чном виде.</tt>

Далее ещё надо не забыть про обратный порядок байт (little-endian).
Т.е. получившееся число в регистре процессора, например,
401ACCCCCCCCCCCD,
в оперативной памяти или в файле на диске будет храниться в перевёрнутом виде (с точностью до БАЙТ, но не БИТ!):
CDCCCCCCCCCC1A40.
Именно это мы и увидим, если в дизассемблерном отладчике, например, M$ Visual Studio, откроем кусок памяти, начиная с адреса <tt>&d</tt>, где <tt>double d = 6.7</tt>.
</li></ul>
Посмотрите ещё <!--a href="../Materials/floats.pdf" target="_blank">методичку</a-->две <a href="sem2_03_floats_ex.html">разобранные задачи</a> с контрольной работы, там разобраны ещё пару примеров переводов туда и обратно.
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
