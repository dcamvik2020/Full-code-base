<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Урок 4: Продвинутая магия статических и динамических библиотек</title>
</head>
<body>
<div style="white-space: pre-wrap;">
А сегодня, дети, сказ пойдёт о магических библиотеках, да не обычных ленинских, а самых настоящих статических и даже волшебных динамических, что было бы в тему нашей последней темы. :-)
Я буду подразумевать, что многомодульные программы вы уже освоили, а с компиляцией программ пофазово вы уже на "ты".
Я оформил ряд модельных проектов, в которых создаются и используются как статические, так и динамические библиотеки, и выложил его <a href="../C2/libs" target="_blank">сюда</a>.
Там есть примеры как для Linux, так и для Windows, поэтому выбираете любимую платформу, привычный компилятор и смотрите исходные файлы, скрипты с командами и параметрами компиляции (для сборки из командной строки), можете даже взять файлы настроек проектов, если хотите попробовать это в соответствующей IDE. А я пока поясню, что к чему.
Поскольку в Windows и Linux библиотеки устроены очень похоже (отличия, конечно, есть, мы просто их касаться не будем), то я буду рассказывать общее для всех платформ, иногда подчёркивая отличия.

Во многих интегрированных средах разработки (IDE) можно заметить три главных типа проектов:
<ol>
<li><b><i>Executable</i></b> (<tt>.exe</tt> / <i>&lt;без_расширения&gt;</i>)
</li>
<li><b><i>Static Library</i></b> (<tt>.lib</tt> / <tt>.a</tt>)
</li>
<li><b><i>Shared Library</i></b> (<tt>.dll</tt> / <tt>.so</tt>)
</li></ol>
С первым из них мы уже достаточно хорошо знакомы, ибо делали программы этого типа весь прошлый семестр и начало этого. А с остальными разберёмся сегодня.

Итак, выложенный <a href="../C2/libs/LinuxGCC" target="_blank">проект</a> (точнее, группа проектов) тривиальный - четыре функции (сложение, вычитание, умножение и деление двух чисел), разбросанные по двум модулям <a href="../C2/libs/LinuxGCC/stat/unit1.c" target="_blank">unit1.c</a> и <a href="../C2/libs/LinuxGCC/stat/unit2.c" target="_blank">unit2.c</a>, и консольное приложение <a href="../C2/libs/LinuxGCC/stat/test.c" target="_blank">test.c</a> с <tt>main</tt>'ом, которое все эти функции вызывает. Даже если вы посмотрите внимательно, то ничего необычного не увидите, ну декларации и декларации <tt>int add(int a, int b);</tt> ... и т.д., коих мы уже повидали на своём веку в разных многомодульных программах. Ничего нового. Правильно, ибо ничто не мешает все эти три модуля просто взять и скомпилировать в один exe-шник.
Почему я разбил четыре функции на два модуля - ну, во-первых, чтобы показать вам, что многомодульными могут быть не только исполняемые файлы (<b><i>Executable</i></b>), но и статические и динамические библиотеки. И, во-вторых, если бы модуль был один, то возник бы резонный вопрос, а зачем его вообще упаковывать в статическую библиотеку, почему бы не обойтись линковкой одного этого модуля. А насчёт динамической - я хотел показать, что из одного и того же набора модулей можно собрать как статическую, так и динамическую библиотеку, причём хоть одновременно. (Если вы посмотрите внимательно с помощью FTP, то эти модули в разных папках вообще выполнены в виде симлинков друг на друга, т.е. это фактически одни и те же файлы.)
<ol>
<li>Итак, начнём со <b><u>статических библиотек</u></b>, ибо с ними проще всего. Что вообще это такое? По большому счёту, это всего лишь банальный архив скомпилированных модулей (<tt>.obj</tt> / <tt>.o</tt>), плюс ещё какой-то заголовок / индекс (хотя в Linux он и не обязателен). Потом при компиляции основного приложения (<b><i>Executable</i></b>) или динамической библиотеки (<b><i>Shared Library</i></b>) она просто указывается линкеру, и всё, что из неё используется, попадает в целевой бинарник. И если статическая библиотека большая (например, <b>libc</b>), то понятное дело, проще указать одно имя <tt>libc.a</tt>, чем 100500 разных модулей (<tt>printf.o</tt>, <tt>scanf.o</tt>, ...).
Формат статической библиотеки сильно зависит от компилятора, от платформы, от архитектуры. И даже если они имеют одно расширение, например, <tt>.lib</tt> в Visual Studio и Borland C++ Builder, нет культурного способа библиотеку от M$VisualC++ подключить в приложение на C++Builder и наоборот. (Говорят, некультурные способы с использованием всяких приспособлений есть, но на данный момент мною не исследовались.)
А в Linux статическая библиотека мало того, что ещё меньше отличается от обычного zip'а, так ещё и открывается стандартными штатными архиваторами системы.
<ul>
<li>Как создать:
<ul>
<li>Из <a href="../C2/libs/MinGW/stat/IDEs/stat" target="_blank">IDE</a>:
Создаём новый проект <b><i>Static Library</i></b>, в нём, как обычно, добавляем новый модуль (<a href="../C2/libs/MinGW/stat/IDEs/stat/unit1.c" target="_blank">unit1.c</a>, неважно как назвать), пишем функции, если надо, ещё добавляем модули (<a href="../C2/libs/MinGW/stat/IDEs/stat/unit2.c" target="_blank">unit2.c</a>), компилируем, благо запускать не потребуется. (Если у вас <a href="../C2/libs/MSVC/stat/IDEs/stat" target="_blank">Microsoft Visual C++ 2008 Express</a>, то <i>Win32 Project -&gt;</i> далее выбрать <i>Static library</i>.)
</li>
<li>Из командной строки:
<ul>
<li><a href="../C2/libs/LinuxGCC/stat" target="_blank">GCC</a>/<a href="../C2/libs/MinGW/stat" target="_blank">MinGW</a>:
<tt>gcc -c unit1.c    <font color="green"># компилируем модули, как обычно</font>
gcc -c unit2.c    <font color="green"># получаем объектные файлы unit1.o и unit2.o</font>
ar -rc libstat.a unit1.o unit2.o    <font color="green"># дальше упаковываем их в библиотеку</font></tt>
Что означают параметры, смотрим <tt>ar --help</tt>, если интересно.
Современные версии <tt>ar</tt> автоматически добавляют к архиву индекс, так что дополнительный вызов утилиты <tt>ranlib</tt> для этих целей не имеет смысла.
</li>
<li>В <a href="../C2/libs/MSVC/stat" target="_blank">Visual Studio</a> схема та же, только <tt>cl</tt> вместо <tt>gcc</tt>, <tt>lib</tt> вместо <tt>ar</tt> и параметры немного другие. Единственное что, в этом компиляторе приходится указывать пути не только к бинарникам утилит, но и к хедерам и библиотекам. Чтобы не загромождать командные строки, я все пути вынес в отдельные переменные. Как я это сделал, см. соответствующий <a href="../C2/libs/MSVC/stat/build.bat" target="_blank">build.bat</a>.
<tt>cl %CFLAGS% /c unit1.c
cl %CFLAGS% /c unit2.c
lib /out:stat.lib unit1.obj unit2.obj</tt>
</li></ul></li></ul></li>
<li>Как использовать (подключить):
<ul>
<li>Для начала из командной строки:
<ul>
<li><a href="../C2/libs/LinuxGCC/stat" target="_blank">GCC</a>/<a href="../C2/libs/MinGW/stat" target="_blank">MinGW</a>:
<ol>
<li>Указываем линкеру нашу библиотеку (без приставки <tt>lib</tt> и расширения <tt>.a</tt>) с помощью ключа <tt>-l<i>библиотека</i></tt>. Ну, аналогичным способом (указанием ключа <tt>-lm</tt>) мы подключали библиотеку <tt>libm</tt>, содержащую реализации математических функций <tt><b>pow</b>()</tt>, <tt><b>sin</b>()</tt>, ... . Так подключаются все стандартные системные библиотеки. Однако в нашем случае не всё так просто. При попытке скомпилировать получим ошибку:
<tt>/usr/bin/ld: cannot find -lstat
collect2: ошибка: выполнение ld завершилось с кодом возврата 1</tt>
По умолчанию линкер не найдёт <tt>-lstat</tt>, потому что будет искать в своих системных каталогах. Чтобы он всё-таки нашёл, надо добавить папку, где лежит наша библиотека, к путям, среди которых выполняется поиск. Делается это с помощью ключа <tt>-L<i>путь</i></tt>, который указывает дополнительный путь, где искать юзерские библиотеки. В нашем случае библиотека лежит в той же директории, где и исходники, где и итоговое приложение собирается, поэтому указываем просто точку. Итого получается:
<tt>gcc test.o -L. -lstat -o teststat.exe</tt>
</li>
<li>Есть и второй способ, без всяких премудростей с ключами <tt>-l</tt> и <tt>-L</tt>, просто насильно указываем линкеру конкретную библиотеку наряду с остальными объектниками:
<tt>gcc test.o libstat.a -o teststat.exe</tt>
возможно, даже с полным путём к библиотеке. Но такой способ менее гибкий (особенно, в вопросе выбора 32- или 64-битной архитектуры или типа сборки статической/динамической) и менее канонiчный. :-)
Добавлю ещё, что порядок указания объектников и библиотек важен для линкера - в случае, если в них содержатся функции с одним именем, то выбирается та, которая встретилась первой.
</li></ol></li>
<li>В <a href="../C2/libs/MSVC/stat" target="_blank">Visual Studio</a> используется второй способ, т.е. просто указывается библиотека среди прочих объектников. Имя линкера - <tt>link</tt>.
<tt>link %LFLAGS% /out:teststat.exe test.obj stat.lib</tt>
Тут имя выходного файла <tt>/out:teststat.exe</tt> указывать необязательно, тогда оно будет выбрано по имени первого объектника.
</li></ul></li>
<li>Из <a href="../C2/libs/MinGW/stat/IDEs/teststat" target="_blank">IDE</a>:
Создаём ещё один проект (<b><i>Executable</i></b>), можно модуль <a href="../C2/libs/MinGW/stat/IDEs/teststat/test.c" target="_blank">test.c</a> отправить туда - главное, чтобы <tt>main</tt> был. Далее к этому проекту надо подключить созданную статическую библиотеку.
Но в IDE у нас появляется другая проблема: библиотеки и исполняемые файлы находятся в разных директориях.
Как это сделать, см. врезку отдельную <a href="sem2_04_adv_link_project_with_library.html">Link project with library</a>.
Очень похожим образом в эти системы добавляются и уже скомпилированные бинарные модули, см. <a href="sem2_04_adv_add_bin_unit.html">Add bin unit</a> - пригодится для задачи <b>bruteforce</b>; а также динамические библиотеки, о которых читайте далее.
</li>
</ul>
</li>
</ul>
</li>
<li>Ну что же, теперь переходим, наконец, к самому интересному - к загадочным таинственным <b><u>динамическим библиотекам</u></b>. В Windows это файлы с расширением <tt>.dll</tt> (<i>Dynamic Link Library</i> или <i>Dynamic Load Library</i>), а в Linux с расширением <tt>.so</tt> (<i>Shared Objects</i>), наверняка вы сталкивались с такими типами файлов. Что же это такое?
<ul>
<li>Если совсем грубо и на пальцах, то это - просто кусок <tt>exe</tt>-шника. Это скомпилированный, почти готовый бинарник, имеющий ту же структуру, что и исполняемые файлы (в Windows формат PE, в Linux формат ELF), так же состоящий из функций, с тем лишь отличием, что нет функции <tt>main</tt>, с которой могло бы начаться выполнение, ну и несколько флажков в заголовках бинарника другие. Обычно библиотеки не являются самостоятельными приложениями, т.е. не имеют основной логики программы, но зато содержат набор утилитарных (дополнительных, служебных) функций, которые могли бы пригодиться не одному приложению, а нескольким. Динамические библиотеки не имеют своего адресного пространства и "живут" в том процессе, который их загрузил, пользуются его ресурсами (памятью (кучей, стеком), правами, открытыми файлами, ...).
</li>
<li>Как следует из их названия, связываются они с приложением не статически (т.е. на этапе компиляции), а динамически (т.е. на этапе выполнения). (Хотя при компиляции они тоже могут быть нужны, но это скорее для самопроверки, "для галочки".) Это даёт возможность уже много позже заменить одну <tt>.dll</tt>-ку (или <tt>.so</tt>-шку) другой такой же, но с новой версией (конечно, если новая содержит как минимум те же функции, что и старая, и интерфейсы их не изменились). В качестве развития этой идеи, иногда приложение уже после запуска может выбирать, какую библиотеку загрузить, с каким именем и из какой папки. На этом может быть построен механизм плагинов.
Обратная сторона этой медали - что приложение получает зависимость от каких-то <tt>.dll</tt>/<tt>.so</tt> и без них работать не будет, поэтому распространяется уже не в виде одного бинарника, а бинарника и нескольких библиотек. И если же оно вдруг по каким-либо причинам не обнаруживает нужную библиотеку там, где ей следует быть, то всё для этого приложения становится очень печально.
</li>
<li>Переиспользование кода (<i>re-use</i>). Аналогично тому, как часто повторяющиеся куски кода выносят в функцию, так и часто использующиеся разными приложениями функции выносятся в статические или/и динамические библиотеки. Поскольку в библиотеках нигде не написано, какое приложение может использовать её функции, а какое нет, то использовать может всякое, которое знает про эту библиотеку и может дотянуться до неё. И в случае динамических библиотек таким образом экономится место не только в файлах на диске, но и в оперативной памяти при одновременной работе нескольких приложений, которые используют одну библиотеку. А весь секрет в том, что <tt>dll</tt>-ка/<tt>so</tt>-шка в память грузится только в единственном экземпляре, при первом обращении, а если запускаются второе, третье и т.д. приложение, то она просто проецируется в их адресное пространство (хоть и не на 100%, но readonly-области точно: код, ресурсы, константы,...). Реализована эта магия с помощью механизма виртуальной памяти, которую мы будем проходить позже.
</li>
<li>Динамические библиотеки - это воплощение принципа модульности программ, но уже не на уровне исходных текстов, а на бинарном уровне. Каждая библиотека имеет свой смысл, каждая занимается своим делом, например, в Linux библиотека <tt>libm.so</tt> содержит математические функции, <tt>libc.so</tt> - стандартные функции Си, а в Windows библиотека <tt>kernel32.dll</tt> - функции для работы с объектами ядра (файлами, памятью, дескрипторами и т.д.), <tt>user32.dll</tt> - функции для работы с графическим интерфейсом GUI (окошками, кнопочками и т.д.); одна библиотека - для работы с авторизацией и безопасностью, другая - для работы с сетью и многое другое.
И если, например, будет обнаружена ошибка в каком-нибудь <tt>printf</tt>'е, то достаточно будет исправить ошибку и перекомпилировать всего лишь одну библиотечку и заменить один файл, а не пересобирать заново всё то хорошее, доброе и вечное, что было запрограммировано в этом мире. :-)
</li>
<li>Бывают не только юзерские библиотеки, но и системные. Вообще говоря, и Windows, и Linux и многие другие современные ОС целиком построены на основе разделяемых библиотек. Есть <tt>dll</tt>/<tt>so</tt>, которые используются положительно всеми нормальными программами: в Линухе это <tt>libc.so</tt>, <tt>libm.so</tt>, <tt>libstdc++.so</tt> - в представлении не нуждаются; в Винде это святая троица <tt>kernel32.dll</tt> (ядро), <tt>user32.dll</tt> (GUI), <tt>gdi32.dll</tt> (рисование и шрифты) (даже для 64-битных ОС!), которые обращаются к более низкоуровневой <tt>ntdll.dll</tt>, которая грузится в память абсолютно любой программы (если это только не Windows 98) и перенаправляет запросы уже напрямую в ядро ОС. Си-шные функции содержатся в <tt>msvcrt.dll</tt> различных версий Вижуал Студий, которая вызывает всё ту же <tt>kernel32.dll</tt>.
Просто загляните в папки <tt>C:\Windows\system32</tt> и <tt>/lib</tt> и посмотрите, сколько там всего!
Например, ваша программа вызывает функции <tt>fopen</tt> и <tt>fprintf</tt>.
В Linux цепочка вызовов будет примерно такая:
<i><tt>программа</tt> -&gt; <tt>libc.so.fopen</tt> (функция стандарта языка ANSI C) -&gt; <tt>libc.so.open</tt> (функция стандарта POSIX) вызывает прерывание -&gt; <tt>vmlinuz</tt> (ядро Linux)</i>
<i><tt>программа</tt> -&gt; <tt>libc.so.fprintf</tt> (функция стандарта языка ANSI C) -&gt; <tt>libc.so.write</tt> (функция стандарта POSIX) вызывает прерывание -&gt; <tt>vmlinuz</tt> (ядро Linux)</i>
А в Windows примерно такая:
<i>программа.exe -&gt; msvcrt.dll.fopen (функция якобы стандарта языка ANSI C) -&gt; msvcrt.dll.open (функция якобы стандарта POSIX) -&gt; kernel32.dll.CreateFileA (функция WinAPI) -&gt; ntdll.dll.NtCreateFile (функция NativeAPI - "родной" подсистемы WindowsNT, "переходничок" в ядро) вызывает прерывание -&gt; ntoskrnl.exe (ядро WindowsNT)</i>
<i>программа.exe -&gt; msvcrt.dll.fprintf (функция якобы стандарта языка ANSI C) -&gt; msvcrt.dll.write (функция якобы стандарта POSIX) -&gt; kernel32.dll.WriteFileEx (функция WinAPI) -&gt; ntdll.dll.NtWriteFile (функция NativeAPI - "родной" подсистемы WindowsNT, "переходничок" в ядро) вызывает прерывание -&gt; ntoskrnl.exe (ядро WindowsNT)</i>
Не знаю, прояснит ли это кому-нибудь Картину Мира, или наоборот только запутает, так что сильно не заморачивайтесь.
Но просто осознайте, что эти системные <tt>dll</tt>/<tt>so</tt> составляют <i>Application Programming Interface (<b>API</b>)</i>, т.е. основное средство обращения из пользовательской программы к сервисам операционной системы.
Ещё один пример: чтобы создать окошко, вам не надо вручную прорисовывать рамки, фон, контур и надписи, следить за перемещением, кликами мыши и нажатий клавиш и т.д. - вам надо лишь вызвать функцию <tt>CreateWindow</tt> из <tt>user32.dll</tt>, указать в параметрах координаты, размеры, заголовок и тип. Всё остальное сделает система за вас.
</li>
<li>Из предыдущего пункта должно стать понятно, что неважно, каким компилятором была собрана динамическая библиотека, а каким - основное приложение, и даже неважно, на каких языках они были написаны. Например, программа на Delphi (язык Object Pascal) может смело вызывать функции из <tt>dll</tt>-ки, написанной на Си или даже на Ассемблере, и наоборот. Т.е. динамические библиотеки - это ещё и средство связи между собой частей программ, написанных на разных языках.
Однако некоторые ограничения всё ещё остаются: должна быть одна платформа (нельзя из программы для Linux просто так вызвать виндовую <tt>dll</tt>-ку и наоборот) и одна архитектура (нельзя из 64-битной программы загрузить 32-битную библиотеку и, разумеется, наоборот; про различные архитектуры процессоров вообще молчу).
Далее можно продолжать ещё очень долго, но нам для начала этого уже достаточно для того, чтобы понять, насколько динамические библиотеки - это круто! :-)
</li>
</ul>

Теперь приступим к созданию продвинутой магии своими руками.
<ul>
<li>Создание динамических библиотек во многом похоже на создание статических (см. выше), но есть и отличия, разумеется.
Как создать:
<ul>
<li>Из <a href="../C2/libs/MinGW/dyn/IDEs/dyn" target="_blank">IDE</a>:
Создаём новый проект <b><i>Shared Library</i></b>, добавляем модули <a href="../C2/libs/MinGW/dyn/IDEs/dyn/unit1.c" target="_blank">unit1.c</a>, <a href="../C2/libs/MinGW/dyn/IDEs/dyn/unit2.c" target="_blank">unit2.c</a>, компилируем, среда сама проставит нужные опции. (Для <a href="../C2/libs/MSVC/dyn/IDEs/dyn" target="_blank">M$</a>: <i>Win32 Project -&gt;</i> далее выбрать <i>DLL</i>.)
И тут нас ждёт первая засада. Дело в том, что в мире Open Source (GCC, MinGW) привыкли, что честному человеку скрывать нечего, поэтому все функции, которые он написал (только если это не <tt>static</tt> функции), по умолчанию экспортируются и видны другим объектным файлам при компиляции, а также "торчат" наружу из динамической библиотеки и даже из готового исполняемого файла. Приходи, смотри и импортируй, кто хошь и что хошь. А вот в мире проприетарщины© (Microsoft®, Borland®) умеют хранить секреты и следят за патентами™ и технологиями™, поэтому обычные функции видны только из <tt>.obj</tt> и <tt>.lib</tt>-файлов для других <tt>.obj</tt> и <tt>.lib</tt>-файлов при сборке, но после линковки они теряют свои имена и практически невозможно сказать, какие функции были внутри данного <tt>.dll</tt> или <tt>.exe</tt>. Соответственно, в Linux GCC и MinGW нам ничего дополнительно делать не надо, а в M$VisualC++ (и Borland) надо пометить те <a href="../C2/libs/MSVC/dyn/IDEs/dyn/unit1.c" target="_blank">функции</a>, которые мы хотим сделать видимыми извне. Делается это с помощью директивы
<tt>__declspec(dllexport)</tt>
или всяких макросов, которые в итоге именно в неё и превращаются.
(В Дельфях, напомню, надо было экспортируемые функции перечислить в секции <tt>exports</tt>.)
Теперь, если мы всё сделали правильно, при компиляции появляется файл <tt>(lib)dyn.dll</tt>, а в M$VC ещё и <tt>dyn.lib</tt> (библиотека импорта), о котором будет сказано позже.
</li>
<li>Из командной строки:
<ul>
<li><a href="../C2/libs/LinuxGCC/dyn" target="_blank">Linux GCC</a>:
Компиляция модулей имеет маленькую особенность: надо указать ещё опцию <tt>-fPIC</tt>, чтобы компилятор генерировал <i>Position Independent Code</i>, чтобы <tt>.so</tt>-шка могла загрузиться в любое место адресного пространства процесса, а не только в какое-то одно конкретное и жёстко заданное.
<tt>gcc -c -fPIC unit1.c
gcc -c -fPIC unit2.c
(gcc -c test.c    <font color="green"># а тут уже необязательно</font>)</tt>
Далее, чтобы собрать не <tt>exe</tt>-шник, а <tt>so</tt>, надо всего лишь линкеру указать ключ <tt>-shared</tt>:
<tt>gcc unit1.o unit2.o -shared -o libdyn.so</tt>
</li>
<li><a href="../C2/libs/MinGW/dyn" target="_blank">MinGW</a>:
В Винде устройство PE-файлов таково, что код и так по умолчанию генерируется перемещаемый, поэтому ключ <tt>-fPIC</tt> не имеет смысла, и указывать его не надо.
<tt>gcc -c unit1.c
gcc -c unit2.c
gcc unit1.o unit2.o -shared -o libdyn.dll</tt>
</li>
<li><a href="../C2/libs/MSVC/dyn" target="_blank">MSVC</a>:
Всё аналогично, я просто оставлю это здесь:
<tt>cl %CFLAGS% /c unit1.c
cl %CFLAGS% /c unit2.c
link %LFLAGS% /dll /out:dyn.dll unit1.obj unit2.obj    <font color="green"># указывать /out:dyn.dll необязательно, тогда имя будет взято по первому объектнику</font></tt>
</li></ul></li></ul>
Готово!
</li>
<li>Как использовать (подключить):
<ul>
<li>Для начала из командной строки:
<ul>
<li><a href="../C2/libs/MinGW/dyn" target="_blank">MinGW</a>:
Всё абсолютно так же, как и для статических библиотек:
<tt>gcc test.o -L. -ldyn -o testdyn.exe</tt>
Обратите внимание, нигде не указывается, какую библиотеку мы хотим прилинковать, статическую или динамическую, поэтому если линкер найдёт динамическую библиотеку, будет сборка динамической, а если статическую - статическая.
Внимательные читатели могли бы задаться вопросом, а зачем вообще указывать динамическую библиотеку при сборке основного приложения? Мы же можем и подменить её позднее, и вообще удалить. Делается это для проверки, что такие функции вообще присутствуют в библиотеке, а также для создания зависимости основного приложения от библиотеки (чтобы при запуске система автоматически подгружала эту <tt>so</tt>-шку/<tt>dll</tt>-ку в адресное пространство процесса). Другими словами, если бы разработчики этих компиляторов были менее ответственными и надёжными и более раздолбайскими, они могли бы сделать, чтобы наличия библиотеки вообще не требовалось. Например, в Delphi просто прописывается <tt>external 'dyn.dll';</tt> после декларации функции, и всё, приложение успешно компилируется, а самой <tt>dyn.dll</tt> может и не существовать в природе.
</li>
<li><a href="../C2/libs/LinuxGCC/dyn" target="_blank">Linux GCC</a>:
Компиляция идентична параграфу про <a href="../C2/libs/MinGW/dyn" target="_blank">MinGW</a>. А вот запуск... Пишем в терминале <tt>./testdyn</tt> и откидываемся на спинку стула, радостно читая ошибку:
<tt>./testdyn: error while loading shared libraries: libdyn.so: cannot open shared object file: No such file or directory</tt>
Мы опять прогулялись по тем же самым граблям, что Linux по умолчанию признаёт только системные библиотеки. Всё ради секьюрности! Мало того, что мы должны указывать каталог с нашей либой при компиляции, так мы ещё должны его напоминать всякий раз при запуске приложения! Чтобы это сделать, приходится указать каталог в переменной окружения <tt>LD_LIBRARY_PATH=<i>путь</i></tt> и экспортировать её в shell (командную оболочку):
<tt>export LD_LIBRARY_PATH=.</tt>
Только после этого система будет принимать также и библиотеки из текущей директории.
</li>
<li><a href="../C2/libs/MSVC/dyn" target="_blank">M$VC++</a>:
А вот тут ещё веселее. Тут другая крайность. При линковке указывается не <tt>dyn.dll</tt>, а... всё равно <tt>dyn.lib</tt>. Только на этот раз это не статическая библиотека, а так называемая <i>библиотека импорта</i>. Это маленький файлик-переходничок между основным приложением и <tt>dll</tt>-кой. В нём не содержится ни байта кода, только имена функций, адреса, по которым их искать в <tt>dll</tt>-ке, и количество параметров (для самопроверки). Генерируется эта библиотека импорта автоматически вместе с компиляцией <tt>dll</tt>-ки. Поэтому и мелкософтовскому линкеру нужна именно она, а сама <tt>dll</tt>-ка может подождать до момента запуска.
<tt>link %LFLAGS% /out:testdyn.exe test.obj dyn.lib</tt>
</li></ul></li>
<li>Из <a href="../C2/libs/MinGW/dyn/IDEs/testdyn" target="_blank">IDE</a>:
Тут ситуация полностью аналогичная подключению статических библиотек (см. <a href="sem2_04_adv_link_project_with_library.html">Link project with library</a>), прописываем зависимости, только в случае <a href="../C2/libs/LinuxGCC/dyn/IDEs/testdyn" target="_blank">GCC</a>/<a href="../C2/libs/MinGW/dyn/IDEs/testdyn" target="_blank">MinGW</a> вместо <tt>libstat.a</tt> указываем <tt>libdyn.dll</tt>, а в случае <a href="../C2/libs/MSVC/dyn/IDEs/testdyn" target="_blank">Вижуал Студии</a> - библиотеку импорта <tt>dyn.lib</tt>.
Единственное что, из таких сред запускать тестовые приложения не очень удобно, поскольку разделяемая библиотека лежит в другой директории, а в случае Linux - и вовсе проблематично, если мы, конечно, не найдём, куда прописать переменную окружения <tt>LD_LIBRARY_PATH</tt>.
</li></ul>
Ещё одно важное отличие между Windows и Linux. В Винде в бинарник жёстко прописывается, какая функция из какой <tt>dll</tt>-ки берётся (например, <tt>msvcrt.printf</tt>, <tt>user32.CreateWindowEx</tt>), а в Линухе в одной таблице перечисляются внешние функции (<tt>printf</tt>, <tt>strcmp</tt>, ...), а в другой - набор <tt>so</tt>-шек, от которых зависит приложение (<tt>libc.so</tt>, <tt>libdyn.so</tt>, ...). И функция берётся из той, которая первая встретилась. Это даёт замечательную возможность хакнуть любую стандартную функцию: написать динамическую библиотеку с пиратской версией известной функции и подгрузить её поперёд стандартных библиотек в память процесса. И вызываться будет именно наша функция, а не системная. В Винде такой халявы не будет, зато там есть масса других дыр в безопасности.

Ну и на посошок.
Динамические библиотеки имеют массу преимуществ перед статическими, но остаётся одна большая уязвимость: если при запуске приложения система не находит хотя бы одну динамическую библиотеку из зависимостей (в том числе и по рекурсивным), то процесс запуска приложения крэшится, не дойдя не только до <tt>main</tt>'а, но и даже до <i>Entry Point</i> (точки входа) <i>startup-кода</i>. Соответственно, у приложения нет ни единого шанса исправить ситуацию. То же самое произойдёт, если библиотеку переименовали или удалили из неё одну из используемых функций. Однако ещё не всё потеряно.
Тот способ, который мы рассмотрели, называется <i>неявным связыванием</i>, поскольку в Сишном/Паскалевском/Ассемблерном коде нигде явно не указывается, какие библиотеки используются и какие функции из них. Всё это решается на этапе линковки. Но есть ещё один способ - <i>явное связывание</i>, при котором динамическое использование библиотек становится ещё более динамическим.



<b>Как использовать динамические библиотеки <u>(Расширенная Магия)</u>.</b>
Замучили непонятки с ключами <tt>-L</tt> и <tt>-l</tt>? Надоело каждый раз при запуске указывать <tt>export LD_LIBRARY_PATH=.</tt> ? Не хочется таскать с собой не только <tt>dll</tt>-ку, но ещё и библиотеку импорта <tt>.lib</tt> от неё? Вы уже написали своё приложение, а ваш сосед ещё не дописал свою <tt>dll</tt>-ку/<tt>so</tt>-шку и вряд ли допишет до 9 утра, а дедлайн уже близок как никогда? Или написал её в среде, которая не предполагает генерацию <tt><i>библиотеки импорта</i>.lib</tt>, а у Вас Visual Studio? Тогда этот параграф для Вас!
Итак, можно начать загружать нашу библиотеку уже после старта программы, например, после того, как мы у юзверя испросили имя этой штуки и где она валяется. В этом случае при линковке нашего приложения не указываются ни динамическая, ни статическая, ни библиотеки импорта. (Кроме <tt>-ldl</tt> в <a href="../C2/libs/LinuxGCC/dyn/build_ex.sh" target="_blank">GCC</a>/<a href="../C2/libs/MinGW/dyn/build_ex.bat" target="_blank">MinGW</a>, где содержатся нужные системные функции.) При запуске, соответственно, тоже не заводятся дополнительные переменные окружения. Не пишутся даже интерфейсы функции в привычном виде.
Но зато в коде программы вызываются стандартные функции <a href="https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya" target="_blank"><tt><b>LoadLibrary</b>()</tt></a> для <a href="../C2/libs/MSVC/dyn/testdyn_ex.c" target="_blank">Винды</a> и <a href="http://www.opennet.ru/man.shtml?topic=dlopen&category=3&russian=0" target="_blank"><tt><b>dlopen</b>()</tt></a> для <a href="../C2/libs/LinuxGCC/dyn/testdyn_ex.c" target="_blank">Линукса</a>. Если библиотека не найдена или загрузка не удалась, можно уйти в другую ветку для обработки этой ситуации. Если же всё OK, то эти функции возвращают дескриптор загруженной библиотеки. Затем, используя этот дескриптор, мы с помощью функций <a href="https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress" target="_blank"><tt><b>GetProcAddress</b>()</tt></a> или <a href="http://www.opennet.ru/man.shtml?topic=dlsym&category=3&russian=0" target="_blank"><tt><b>dlsym</b>()</tt></a> соответственно ищем в этой библиотеке нужные функции. Если не найдено, опять это не смертельно, можно попробовать что-нибудь ещё. Если всё ОК, то нам возвращают адреса этих функций в библиотеке, и вот тут нам как нельзя кстати пригодилась такая конструкция Си, как <i><u>указатели на функции</u></i>. ;-) А затем уже можно вызывать эти функции, как обычные. После того, как поработали, надо выгрузить библиотеку из памяти функциями <a href="https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-freelibrary" target="_blank"><tt><b>FreeLibrary</b>()</tt></a> / <a href="http://www.opennet.ru/man.shtml?topic=dlclose&category=3&russian=0" target="_blank"><tt><b>dlclose</b>()</tt></a>. Всё точно так же, как и при работе с файлами!
Мы избавляемся от многих проблем, связанных с динамическими библиотеками, но зато получаем привязку в коде к конкретной операционной системе (хорошо хоть не к компилятору!).
Рабочий пример Вы можете найти в файлах <a href="../C2/libs/MinGW/dyn/testdyn_ex.c" target="_blank">testdyn_ex.c</a> и скриптах сборки <a href="../C2/libs/MinGW/dyn/build_ex.bat" target="_blank">build_ex</a>.
Используя такую технику, можно перебрать все <tt>dll</tt>-ки/<tt>so</tt>-шки в папке с проектом и повызывать оттуда определённые функции с заданным интерфейсом. Это и будет классический механизм <b><i>плагинов</i></b>.

Надеюсь, вы поняли, что динамические библиотеки предоставляют массу интересных и полезных возможностей, но и мороки с ними зато намного больше.



<b>P.S. А что же насчёт обещанного <tt>extern "C"</tt>?</b>
Директива <tt>extern "C"</tt> используется для связи модулей и библиотек, написанных на разных языках Си и C++, и пишется в программах на C++ перед декларациями функций, которые надо экспортировать или импортировать по чисто Си-шным правилам.
Вы уже знаете, что в C++, в отличие от Си, разрешена перегрузка функций (т.е. существование разных функций с одним именем, но разными параметрами). Поэтому, чтобы их различить, компилятор в <tt>.dll</tt>/<tt>.so</tt>/<tt>.obj</tt>/<tt>.o</tt> оставляет не просто имя функции <tt>add</tt> (как это делается в Си), но и зашифровывает туда и параметры и возвращаемое значение, поэтому <tt>add</tt> превращается в <tt>_Z3addii</tt> или в <tt>?add@@YAHHH@Z</tt> или ещё в какую-нибудь гадость (ад), в зависимости от компилятора и версии оного. Это <i>искажение имён</i> получило название <i>name mangling</i>. Если библиотека/модуль была написана на Си, то экспортируется функция <tt>add</tt>, а если вызывающее приложение пишется на C++ и интерфейс такой:
<tt>int add(int a, int b);</tt>
то искать оно будет <tt>_Z3addii</tt>. Если наоборот - значит, наоборот. Так вот, директива
<tt>extern "C" int add(int a, int b);</tt>
в C++ отключает этот самый <i>name mangling</i>.
Остаётся добавить, что в программе на Си директива <tt>extern "C"</tt> вызовет ошибку компиляции, поэтому, если хочется, чтобы наш модуль одинаково успешно работал как в Си, так и в C++, приходится эту <tt>extern "C"</tt> обрамлять директивами препроцессора <tt>#ifdef __cplusplus</tt>.

Я в этом эпичном повествовании не коснулся ещё многих аспектов, таких как экспортирование функций из <tt>dll</tt> по индексу, соглашения о вызовах, <tt>.def</tt>-файлы, функции <tt><b>DllMain</b>()</tt>...
Но это уже совсем другая история. Спокойной ночи, Страна! ©
</li>
</ul>
</li>
</ol>
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
