<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Семинар 13: Деревья, большие и бинарные; а также сканирование каталогов - Практика</title>
</head>
<body>
<div style="white-space: pre-wrap;">
По старой доброй традиции выкладываю материалы, имеющие отношение к позавчерашнему семинару:
<ol>
<li><b>Бинарное дерево поиска:</b>
<a href="../C1/structures/tree2search" target="_blank">tree2search</a> - папка с исходниками и настройками под разные IDE (среды разработки). Также это пример многомодульной программы.
<ul>
<li><a href="../C1/structures/tree2search/list.c" target="_blank">list.c</a> - уже знакомый нам односвязный список, который просто наряжается в стек и очередь.
</li>
<li><a href="../C1/structures/tree2search/list.h" target="_blank">list.h</a> - общие декларации для списка, использующиеся в модулях <a href="../C1/structures/tree2search/list.c" target="_blank">list.c</a>, <a href="../C1/structures/tree2search/tree2search.c" target="_blank">tree2search.c</a> и <a href="../C1/structures/tree2search/addon.c" target="_blank">addon.c</a>
</li>
<li><a href="../C1/structures/tree2search/tree2search.c" target="_blank">tree2search.c</a> - главный модуль - реализация бинарного дерева поиска.
Поиск элемента и добавление нового довольно тривиальны и рекурсивны, но над удалением пришлось попотеть.
Функция <tt><b>dfs</b>()</tt> - обход дерева в глубину с помощью стека,
функция <tt><b>wfs</b>()</tt> - обход дерева в ширину с помощью очереди,<!-- (фактически, это всё задача 1.8 из второго задания из задавальника)-->
функция <tt><b>traverse</b>()</tt> - обход дерева рекурсивно в глубину<!-- (задача 1.9)-->.
Всё это префиксное описание дерева, а уничтожение дерева - постфиксное.
</li></ul>
Поиграйтесь с этим проектом, поразбирайтесь, опять же, за feedback буду благодарен.
Надо знать общие свойства бинарного дерева поиска, что такое обход в глубину и чем отличается от обхода в ширину, а также, что такое стек и очередь.
</li>
<li><b>Обычное дерево:</b>
<ul>
<li><a href="../C1/structures/tree.c" target="_blank">tree</a> - реализация дерева в общем виде. Не намного отличается от работы с двусвязным списком.
Посмотрите, погоняйте, если найдёте ошибки - мне сообщите.
Надеюсь, пригодится вам когда-нибудь в качестве отправной точки, когда понадобится реализовать собственное дерево (это одна из трёх сверхзадач по жизни у каждого настоящего мужчины, не забывайте это! :-) ).
</li>
<li><a href="../C1/structures/read_tree.c" target="_blank">read_tree</a> - код, читающий дерево (иерархические данные, оформленные в виде строк с отступами) из файла (консоль stdin - тоже файл), парсящий его и воссоздающий дерево в памяти. Я называю такой хитрый алгоритм обратной рекурсией или свёрткой рекурсии.
</li>
<li><a href="../C1/structures/read_tree2.c" target="_blank">read_tree2</a> - то же самое, но для бинарного дерева. Посмотрите, потестируйте. Если вдруг найдёте ошибки - сообщайте мне, получите доп.балл.
</li></ul></li>
<li><b>Сканирование каталогов:</b>
Для тех, кто "многабукв ниасилил", я налабал пару маленьких примерчиков:
<ul>
<li><a href="../C1/flist_lin.c" target="_blank">flist_lin</a> - перебор (нерекурсивный) всех файлов и папок в данной директории в Linux,
</li>
<li><a href="../C1/flist_win.c" target="_blank">flist_win</a> - в Windows.
</li></ul></li>
<li><a href="../C1/calc0.c" target="_blank">calc0</a> - моя реализация <b>Калькулятора</b> без скобок. Хочу, чтобы у всех этот способ был. Соответственно, задача calc0 закрывается для сдачи (хотя почти все успешно её решили), вместо неё решайте calc1.
</li>
</ol>
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
