<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Семинар 10: qsort</title>
</head>
<body>
<div style="white-space: pre-wrap;">
Всё, что вы всегда хотели знать про <tt><b>qsort</b>()</tt>, но всё время боялись спросить.
<tt><b>qsort</b></tt> - стандартная функция Си быстрой сортировки массива. Любого типа. По любому, определяемому пользователю, критерию.

Итак, для простоты рассмотрим банальный целочисленный массив
<tt>	int A[] = {1, 5, 2, 4, 3};</tt>
размера
<tt>	int n = <b>sizeof</b> A / <b>sizeof</b> A[0]; <font color="green">// == 5</font></tt>
Смотрим описание <tt><b>qsort</b></tt> в штатной справке в Линуксе. Пишем команду в терминале:
<tt>	man qsort</tt>
И первое, что видим:
<tt>       #include &lt;stdlib.h&gt;

       void <b>qsort</b>(void *base, size_t nmemb, size_t size,
                  int (<b><i>*compar</i></b>)(const void *, const void *));

       Функция <b>qsort</b>() сортирует массив из nmemb размером size. Аргумент base указывает на начало массива.</tt>

Т.е. подключаем указанный хедер, вызываем <tt><b>qsort</b>()</tt>, первым параметром указываем сам сортируемый массив (имя массива является адресом его начала), вторым - число элементов массива. Далее интересно. <tt><b>qsort</b>()</tt> видит только адрес начала куска памяти (т.е. его левую границу) и целое число. Если ей надо сортировать 10 <tt>int</tt>'ов, то это 40 байт, если 10 <tt>char</tt>'ов, то 10 байт, а если 10 <tt>double</tt>'в, то все 80 байт. Поэтому надо указать ещё размер одного элемента (третьим параметром), тогда размер куска памяти (а соответственно, и его правая граница) будет чётко определен.
<tt>	<b>qsort</b>(A, n, sizeof(int), <b><i>cmp_func</i></b>);</tt>
Но самое интересное - это четвёртый параметр. В интерфейсе этот зубастый крокодил выглядит несколько пугающе, но мы его научились укрощать на этом занятии.
Это - указатель на функцию. От декларации функции отличается только тем, что имя функции идёт со звёздочкой и в скобках.
Т.о., четвёртым параметром идёт функция сравнения двух каких-то элементов массива, которая должна ответить на вопрос, какой из них больше, а какой меньше (или они равны), и именно эта функция определяет критерий (правило), по которому будем сортировать. А также по возрастанию сортируем или по убыванию.
Имя функции вместо <tt><b><i>compar</i></b>()</tt> может быть любым, например, <tt><b><i>cmp_func</i></b>()</tt>.
Функция <tt><b>qsort</b>()</tt> последовательно вызывает функцию <tt><b><i>compar</i></b>()</tt> (в данном случае <tt><b><i>cmp_func</i></b>()</tt>) несколько раз, передавая ей два каких-то элемента массива (например, 10-й и 3-й; 2-й и 5-й; и т.д.). Но поскольку элементы могут быть не только <tt>int</tt>'овые, но и <tt>double</tt>'вые, да и вообще типа структура, то копировать их в параметры функции <tt><b><i>compar</i></b>()</tt> накладно (да и вообще, <tt><b>qsort</b>()</tt> не знает точный тип массива), поэтому передаёт их по указателю, причём для пущей универсальности по нетипизированному. А чтобы случайно эти элементы не поменяли, то ещё и со спецификатором <tt>const</tt>.
Итак, пишем функцию сравнения (сначала распишу максимально подробно, чтобы стало понятно; а потом буду писать максимально коротко):

<tt><font color="green">//имя может быть любым; добавляем имена параметров p1 и p2</font>
<font color="green">//представим, что p1 указывает на 2-й элемент массива A (т.е. на 5-ку), а p2 - на 5-й (на 3-ку), считая от 1</font>
int <b><i>cmp_func</i></b>(const void *p1, const void *p2) {
	<font color="green">// указатели p1 и p2 нетипизированные; с ними ничего сделать не получится, кроме как привести к типизированным</font>
	const int *pa, *pb; <font color="green">// qsort() не знает тип массива, но мы-то знаем... это int!</font>
	int a, b;
	pa = (const int *) p1;
	pb = (const int *) p2;
	<font color="green">// теперь прочитаем, чему равны сравниваемые элементы массива</font>
	<font color="green">// т.е. залезем в сам массив A (который в main'е) и скопируем два его элемента в стек функции <b><i>cmp_func</i></b>() - в переменные a и b</font>
	a = *pa;
	b = *pb;
	<font color="green">// функция сравнения должна вернуть положительное число, если первый элемент больше второго,</font>
	if (a &gt; b)
		return 1;
	<font color="green">// отрицательное число, если наоборот,</font>
	if (a &lt; b)
		return -1;
	<font color="green">// и 0, если элементы равны</font>
	return 0;
}</tt>

В зависимости от того, что вернёт <tt><b><i>cmp_func</i></b>()</tt>, функция <tt><b>qsort</b>()</tt> сама поменяет местами эти элементы массива. Или не поменяет - зависит от её алгоритма.
Но после этого она вызовет <tt><b><i>cmp_func</i></b>()</tt> с какими-то двумя другими элементами. И т.д.
Запускаем и радуемся: напечатано <tt>1 2 3 4 5</tt>.

Теперь будем постепенно упрощать эту функцию.
Легко заметить, что если мы вернём
<tt>	return a - b;</tt>
то интерфейс функции <tt><b><i>cmp_func</i></b>()</tt> будет соблюдён, и получится то, что надо.
А если вернём <tt>return b - a;</tt> то меньший параметр станет бОльшим и наоборот, и функция <tt><b>qsort</b></tt> отсортирует не по возрастанию, а по убыванию.

Теперь следующий шаг. Копировать себе элементы массива слишком долго и неэффективно. А если это не <tt>int</tt>, а целая структура, из которой нам нужно всего одно поле?
Поэтому попробуем обойтись без переменных <tt>int a, b;</tt> а работать прямо с элементами массива <tt>A</tt> на месте.

<tt>	const int *pa, *pb;
	pa = (const int *) p1;
	pb = (const int *) p2;
	return *pa - *pb;</tt>

ну осталось только вместо <tt>pa</tt> подставить <tt>(const int *)p1</tt>, а вместо <tt>pb</tt> подставить <tt>(const int *)p2</tt>, и можно обойтись без лишних указателей, и вообще всего одной строчкой.

<tt>	return *(const int *)p1 - *(const int *)p2;</tt>
</div>
<div id="comments"></div>
<script src="comments.js"></script>
</body>
</html>
