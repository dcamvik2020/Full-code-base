<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Ben Lynn">
  <title>Волшебство Git</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Волшебство Git</h1>
<h2 class="author">Ben Lynn</h2>
<h3 class="date">Август 2007</h3>
</header>
<h1 id="_от_редактора_перевода">От редактора перевода</h1>
<p>Не буду долго вас задерживать перед интересным чтением, лишь дам небольшие пояснения по переводу терминологии.</p>
<p>Приводя текст к единому стилю, я старался в первую очередь сохранить 
его цельность и легкость восприятия, а уже затем следовать чистоте 
языка. Поэтому на русский переведены лишь устоявшиеся термины; в тех 
случаях, когда общепринятого русского слова нет, была оставлена калька с
 английского. Например, используется слово «каталог» вместо 
«директория»; «хранилище» вместо «репозиторий» или «репозитарий»; 
«слияние» вместо «мерж»; и «ветка» вместо «бранч». Обратные примеры: 
«коммит», а не «фиксация»; «хук», а не «крюк»; «патч», а не «заплатка». 
Единственное исключение сделано для фразы «буферная зона» вместо 
«область стейджинг» и, соответственно, слова «буфер» вместо «стейдж»: 
поскольку здесь уже не только перевод, но и калька не есть 
общеупотребительные термины, то лучше было попытаться объяснить смысл 
понятия.</p>
<p>Надеюсь, эти краткие пояснения не оставят для вас неровностей в 
переводе и позволят погрузиться в текст книги без помех. Приятного 
чтения.</p>
<h1 id="_предисловие">Предисловие</h1>
<p><a href="http://git.or.cz/">Git</a> это швейцарский нож управления 
версиями — надежный универсальный многоцелевой инструмент, чья 
черезвычайная гибкость делает его сложным в изучении даже для многих 
профессионалов.</p>
<p>Как говорил Артур Кларк, любая достаточно развитая технология 
неотличима от волшебства. Это отличный подход к Git: новички могут 
игнорировать принципы его внутренней работы и рассматривать Git как 
нечто восхищающее друзей и приводящее в бешенство врагов своими 
чудесными способностями.</p>
<p>Вместо того, чтобы вдаваться в подробности, мы предоставим 
приблизительные инструкции для получения конкретных результатов. При 
частом использовании вы постепенно поймете, как работает каждый трюк и 
как приспосабливать рецепты под ваши нужды.</p>
<ul>
<li><p><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn/">Китайский (упрощенный)</a>: JunJie, Meng и JiangWei.</p></li>
<li><p><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/es/">Испанский</a>: Rodrigo Toledo.</p></li>
<li><p><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/de/">Немецкий</a>: Benjamin Bellee и Armin Stebich. Armin также разместил <a href="http://gitmagic.lordofbikes.de/">немецкий перевод на его сайте</a>.</p></li>
<li><p><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/ru/">Русский</a>: Тихон Тарнавский, Михаил Дымсков и другие.</p></li>
<li><p><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/uk/">Украинский</a>: Владимир Боденчук.</p></li>
<li><p><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/fr/">Французский</a>: Alexandre Garel. Также размещён на <a href="http://tutoriels.itaapy.com/">itaapy</a>.</p></li>
<li><p><a href="http://www.slideshare.net/slide_user/magia-git">Португальский</a>: Leonardo Siqueira Rodrigues [<a href="http://www.slideshare.net/slide_user/magia-git-verso-odt">в формате ODT</a>].</p></li>
</ul>
<ul>
<li><p><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/ru/book.html">HTML одной страницей</a>: чистый HTML без CSS.</p></li>
<li><p><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/ru/book.pdf">PDF файл</a>: для печати.</p></li>
<li><p><a href="http://packages.debian.org/gitmagic">Пакет Debian</a>, <a href="http://packages.ubuntu.com/gitmagic">пакет Ubuntu</a>: получите локальную копию этого сайта. Придется кстати, <a href="http://csdcf.stanford.edu/status/">если этот сервер будет недоступен</a>.</p></li>
</ul>
<h2 id="_благодарности">Благодарности</h2>
<p>Я очень ценю, что столь многие люди работали над переводами этих 
строк. Я благодарен названным выше людям за их усилия, расширившие мою 
аудиторию.</p>
<p>Dustin Sallings, Alberto Bertogli, James Cameron, Douglas 
Livingstone, Michael Budde, Richard Albury, Tarmigan, Derek Mahar, Frode
 Aannevik, Keith Rarick, Andy Somerville, Ralf Recker, Øyvind A. Holm, 
Miklos Vajna, Sébastien Hinderer, Thomas Miedema, Joe Malin и Tyler 
Breisacher содействовали в правках и доработках.</p>
<p>François Marier сопровождает пакет Debian, изначально созданный Daniel Baumann.</p>
<p>Мои благодарности остальным за вашу поддержку и похвалы. Мне очень 
хотелось процитировать вас здесь, но это могло бы возвысить ваше 
тщеславие до невообразимых высот.</p>
<p>Если я случайно забыл упомянуть вас, пожалуйста, напомните мне или просто вышлите патч.</p>
<ul>
<li><p><a href="http://repo.or.cz/" class="uri">http://repo.or.cz/</a> хостинг свободных проектов. Первый сайт Git-хостинга. Основан и поддерживается одним из первых разработчиков Git.</p></li>
<li><p><a href="http://gitorious.org/" class="uri">http://gitorious.org/</a> другой сайт Git-хостинга, нацеленный на проекты с открытым кодом.</p></li>
<li><p><a href="http://github.com/" class="uri">http://github.com/</a> хостинг для проектов с открытым кодом; а также для закрытых проектов (на платной основе).</p></li>
</ul>
<p>Большое спасибо каждому из этих сайтов за размещение этого руководства.</p>
<h2 id="_лицензия">Лицензия</h2>
<p>Это руководство выпущено под <a href="http://www.gnu.org/licenses/gpl-3.0.html">GNU General Public License 3-й версии</a>. Естественно, исходный текст находится в хранилище Git и может быть получен командой:</p>
<pre><code>$ git clone git://repo.or.cz/gitmagic.git  # Создаст каталог "gitmagic".</code></pre>
<p>или с одного из зеркал:</p>
<pre><code>$ git clone git://github.com/blynn/gitmagic.git
$ git clone git://gitorious.org/gitmagic/mainline.git</code></pre>
<h1 id="_введение">Введение</h1>
<p>Чтобы объяснить, что такое управление версиями, я буду использовать аналогии. Если нужно более точное объяснение, обратитесь к <a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D1%8F%D0%BC%D0%B8">статье википедии</a>.</p>
<h2 id="_работа_это_игра">Работа - это игра</h2>
<p>Я играл в компьютерные игры почти всю свою жизнь. А вот использовать 
системы управления версиями начал уже будучи взрослым. Полагаю, я такой 
не один, и сравнение этих двух занятий может помочь объяснению и 
пониманию концепции.</p>
<p>Представьте, что редактирование кода или документа — игра. Далеко 
продвинувшись, вы захотите сохраниться. Для этого вы нажмете на кнопку 
«Сохранить» в вашем любимом редакторе.</p>
<p>Но это перезапишет старую версию. Это как в древних играх, где был 
только один слот для сохранения: конечно, вы можете сохраниться, но вы 
больше никогда не сможете вернуться к более раннему состоянию. Это 
досадно, так как прежнее сохранение могло указывать на одно из очень 
интересных мест в игре, и может быть, однажды вы захотите вернуться к 
нему. Или, что еще хуже, вы сейчас находитесь в безвыигрышном положении и
 вынуждены начинать заново.</p>
<h2 id="_управление_версиями">Управление версиями</h2>
<p>Во время редактирования вы можете «Сохранить как…» в другой файл, или
 скопировать файл куда-нибудь перед сохранением, чтобы уберечь более 
старые версии. Может быть, заархивировав их для экономии места на диске.
 Это самый примитивный вид управления версиями, к тому же требующий 
интенсивной ручной работы. Компьютерные игры прошли этот этап 
давным-давно, в большинстве из них есть множество слотов для сохранения с
 автоматическими временны́ми метками.</p>
<p>Давайте немного усложним условия. Пусть у вас есть несколько файлов, 
используемых вместе, например, исходный код проекта или файлы для 
вебсайта. Теперь, чтобы сохранить старую версию, вы должны скопировать 
весь каталог. Поддержка множества таких версий вручную неудобна и быстро
 становится дорогим удовольствием.</p>
<p>В некоторых играх сохранение — это и есть каталог с кучей файлов 
внутри. Игры скрывают детали от игрока и предоставляют удобный интерфейс
 для управления различными версиям этого каталога.</p>
<p>В системах управления версиями всё точно так же. У них у всех есть 
приятный интерфейс для управления каталогом с вашим скарбом. Можете 
сохранять состояние каталога так часто, как пожелаете, а затем 
восстановить любую из предыдущих сохраненных версий. Но, в отличие от 
компьютерных игр, они существенно экономят дисковое пространство. Обычно
 от версии к версии изменяется только несколько файлов, и то ненамного. 
Хранение лишь различий вместо полных копий требует меньше места.</p>
<h2 id="_распределенное_управление">Распределенное управление</h2>
<p>А теперь представьте очень сложную компьютерную игру. Ее настолько 
сложно пройти, что множество опытных игроков по всему миру решили 
объединиться и использовать общие сохранения, чтобы попытаться выиграть.
 Прохождения на скорость — живой пример. Игроки, специализирующиеся на 
разных уровнях игры, объединяются, чтобы в итоге получить потрясающий 
результат.</p>
<p>Как бы вы организовали такую систему, чтобы игроки смогли легко получать сохранения других? А загружать свои?</p>
<p>В былые времена каждый проект использовал централизованное управление
 версиями. Какой-нибудь сервер хранил все сохраненные игры. И никто 
больше. Каждый держал лишь несколько сохранений на своей машине. Когда 
игрок хотел пройти немного дальше, он выкачивал самое последнее 
сохранение с главного сервера, играл немного, сохранялся и закачивал уже
 свое сохранение обратно на сервер, чтобы остальные могли им 
воспользоваться.</p>
<p>А что если игрок по какой-то причине захотел использовать более 
старую сохраненную игру? Возможно, нынешнее сохранение безвыигрышно, 
потому что кто-то забыл взять некий игровой предмет еще на третьем 
уровне, и нужно найти последнее сохранение, где игру всё еще можно 
закончить. Или, может быть, хочется сравнить две более старые 
сохраненные игры, чтобы установить вклад конкретного игрока.</p>
<p>Может быть много причин вернуться к более старой версии, но выход 
один: нужно запросить ту старую сохраненную игру у центрального сервера.
 Чем больше сохраненных игр требуется, тем больше понадобится 
связываться с сервером.</p>
<p>Системы управления версиями нового поколения, к которым относится 
Git, известны как распределенные системы, их можно понимать как 
обобщение централизованных систем. Когда игроки загружаются с главного 
сервера, они получают каждую сохраненную игру, а не только последнюю. 
Они как бы зеркалируют центральный сервер.</p>
<p>Эти первоначальные операции клонирования могут быть ресурсоемкими, 
особенно при длинной истории, но сполна окупаются при длительной работе.
 Наиболее очевидная прямая выгода состоит в том, что если вам зачем-то 
потребуется более старая версия, взаимодействие с сервером не 
понадобится.</p>
<h2 id="_глупые_предрассудки">Глупые предрассудки</h2>
<p>Широко распространенное заблуждение состоит в том, что распределенные
 системы непригодны для проектов, требующих официального 
централизованного хранилища. Ничто не может быть более далеким от 
истины. Получение фотоснимка не приводит к тому, что мы крадем чью-то 
душу. Точно так же клонирование главного хранилища не уменьшает его 
важность.</p>
<p>В первом приближении можно сказать, что все, что делает 
централизованная система управления версиями, хорошо сконструированная 
распределенная система может сделать лучше. Сетевые ресурсы просто 
дороже локальных. Хотя дальше мы увидим, что в распределенном подходе 
есть свои недостатки, вы вряд ли ошибетесь в выборе, руководствуясь этим
 приближенным правилом.</p>
<p>Небольшому проекту может понадобиться лишь частица функционала, 
предлагаемого такой системой. Но использование плохо масштабируемой 
системы для маленьких проектов подобно использованию римских цифр в 
расчетах с небольшими числами.</p>
<p>Кроме того, проект может вырасти сверх первоначальных ожиданий. 
Использовать Git с самого начала — это как держать наготове швейцарский 
нож, даже если вы всего лишь открываете им бутылки. Однажды вам безумно 
понадобится отвертка и вы будете рады, что под рукой есть нечто большее,
 чем простая открывалка.</p>
<h2 id="_конфликты_при_слиянии">Конфликты при слиянии</h2>
<p>Для этой темы аналогия с компьютерной игрой становится слишком 
натянутой. Вместо этого, давайте вернемся к редактированию документа.</p>
<p>Итак, допустим, что Алиса вставила строчку в начале файла, а Боб — в 
конце. Оба они закачивают свои изменения. Большинство систем 
автоматически сделает разумный вывод: принять и соединить их изменения 
так, чтобы обе правки — и Алисы, и Боба — были применены.</p>
<p>Теперь предположим, что и Алиса, и Боб внесли разные изменения в одну
 и ту же строку. В этом случае невозможно продолжить без человеческого 
вмешательства. Тот из них, кто вторым закачает на сервер изменения, 
будет информирован о <em>конфликте слияния</em> (merge conflict), и должен либо предпочесть одно изменение другому, либо скорректировать всю строку.</p>
<p>Могут случаться и более сложные ситуации. Системы управления версиями
 разрешают простые ситуации сами и оставляют сложные для человека. 
Обычно такое их поведение поддается настройке.</p>
<h1 id="_базовые_операции">Базовые операции</h1>
<p>Прежде чем погружаться в дебри многочисленных команд Git, попробуйте 
воспользоваться приведенными ниже простыми примерами, чтобы немного 
освоиться. Каждый из них полезен, несмотря на свою простоту. На самом 
деле первые месяцы использования Git я не выходил за рамки материала 
этой главы.</p>
<h2 id="_сохранение_состояния">Сохранение состояния</h2>
<p>Собираетесь попробовать внести некие радикальные изменения? 
Предварительно создайте снимок всех файлов в текущем каталоге с помощью 
команд</p>
<pre><code>$ git init
$ git add .
$ git commit -m "Моя первая резервная копия"</code></pre>
<p>Теперь, если новые правки всё испортили, можно восстановить первоначальную версию:</p>
<pre><code>$ git reset --hard</code></pre>
<p>Чтобы вновь сохранить состояние:</p>
<pre><code>$ git commit -a -m "Другая резервная копия"</code></pre>
<h2 id="_добавление_удаление_переименование">Добавление, удаление, переименование</h2>
<p>Приведенный выше пример отслеживает только те файлы, которые существовали при первом запуске <strong>git add</strong>. Если вы создали новые файлы или подкаталоги, придется сказать Git'у:</p>
<pre><code>$ git add readme.txt Documentation</code></pre>
<p>Аналогично, если хотите, чтобы Git забыл о некоторых файлах:</p>
<pre><code>$ git rm ляп.h старье.c
$ git rm -r улики/</code></pre>
<p>Git удалит эти файлы, если вы не удалили их сами.</p>
<p>Переименование файла — это то же, что удаление старого имени и добавления нового. Для этого есть <strong>git mv</strong>, которая имеет тот же синтаксис, что и команда <strong>mv</strong>. Например:</p>
<pre><code>$ git mv bug.c feature.c</code></pre>
<h2 id="_расширенные_отмена_возврат">Расширенные отмена/возврат</h2>
<p>Иногда просто хочется вернуться назад и забыть все изменения до 
определенного момента, потому что все они были неправильными. В таком 
случае</p>
<pre><code>$ git log</code></pre>
<p>покажет список последних коммитов и их хеши SHA1:</p>
<pre><code>commit 766f9881690d240ba334153047649b8b8f11c664
Author: Bob &lt;bob@example.com&gt;
Date:   Tue Mar 14 01:59:26 2000 -0800

    Заменил printf() на write().

commit 82f5ea346a2e651544956a8653c0f58dc151275c
Author: Alice &lt;alice@example.com&gt;
Date:   Thu Jan 1 00:00:00 1970 +0000

    Начальный коммит.</code></pre>
<p>Для указания коммита достаточно первых нескольких символов его хеша, но можете скопировать и весь хеш. Наберите:</p>
<pre><code>$ git reset --hard 766f</code></pre>
<p>для восстановления состояния до указанного коммита и удаления всех последующих безвозвратно.</p>
<p>Возможно, в другой раз вы захотите быстро перескочить к старому состоянию. В этом случае наберите</p>
<pre><code>$ git checkout 82f5</code></pre>
<p>Эта команда перенесет вас назад во времени, сохранив при этом более 
новые коммиты. Однако, как и в фантастических фильмах о путешествиях во 
времени, если теперь вы отредактируете и закоммитите код, то попадете в 
альтернативную реальность, потому что ваши действия отличаются от тех, 
что были в прошлый раз.</p>
<p>Эта альтернативная реальность называется «веткой» (branch, прим. пер.), и <a href="#branch">чуть позже мы поговорим об этом подробнее</a>. А сейчас просто запомните, что команда</p>
<pre><code>$ git checkout master</code></pre>
<p>вернет вас обратно в настоящее. Кроме того, чтобы не получать 
предупреждений от Git, всегда делайте commit или сбрасывайте изменения 
перед запуском checkout.</p>
<p>Еще раз воспользуемся аналогией с компьютерными играми:</p>
<ul>
<li><p><strong>git reset --hard</strong>: загружает ранее сохраненную игру и удаляет все версии, сохраненные после только что загруженной.</p></li>
<li><p><strong>git checkout</strong>: загружает старую игру, но если вы 
продолжаете играть, состояние игры будет отличаться от более новых 
сохранений, которые вы сделали в первый раз. Любая игра, которую вы 
теперь сохраняете, попадает в отдельную ветку, представляющую 
альтенативную реальность, в которую вы попали. <a href="#branch">Мы обсудим это позже</a>.</p></li>
</ul>
<p>Можно также восстановить только определенные файлы и подкаталоги, перечислив их имена после команды:</p>
<pre><code>$ git checkout 82f5 какой-то.файл другой.файл</code></pre>
<p>Будьте внимательны: такая форма <strong>checkout</strong> может молча
 перезаписать файлы. Чтобы избежать неприятных неожиданностей, 
выполняйте commit перед checkout, особенно если вы только изучаете Git. 
Вообще, если вы не уверены в какой-либо операции, будь то команда Git 
или нет, выполните предварительно <strong>git commit -a</strong>.</p>
<p>Не любите копировать и вставлять хеши? Используйте</p>
<pre><code>$ git checkout :/"Моя первая р"</code></pre>
<p>для перехода на коммит, чье описание начинается с приведенной строки.</p>
<p>Можно также запросить 5-ое с конца сохраненное состояние:</p>
<pre><code>$ git checkout master~5</code></pre>
<h2 id="_откаты">Откаты</h2>
<p>В зале суда пункты протокола могут вычеркиваться прямо во время 
слушания. Подобным образом и вы можете выбирать коммиты для отмены.</p>
<pre><code>$ git commit -a
$ git revert 1b6d</code></pre>
<p>отменит коммит с заданным хешем. Откат будет сохранен в виде нового коммита. Можете запустить <strong>git log</strong>, чтобы убедиться в этом.</p>
<h2 id="_создание_списка_изменений">Создание списка изменений</h2>
<p>Некоторым проектам нужен <a href="http://en.wikipedia.org/wiki/Changelog">список изменений</a> (changelog, прим. пер.). Создайте его такой командой:</p>
<pre><code>$ git log &gt; ChangeLog</code></pre>
<h2 id="_скачивание_файлов">Скачивание файлов</h2>
<p>Получить копию проекта под управлением Git можно, набрав</p>
<pre><code>$ git clone git://сервер/путь/до/файлов</code></pre>
<p>Например, чтобы получить все файлы, которые я использовал для создания этого документа,</p>
<pre><code>$ git clone git://git.or.cz/gitmagic.git</code></pre>
<p>Позже мы поговорим о команде <strong>clone</strong> подробнее.</p>
<h2 id="_держа_руку_на_пульсе">Держа руку на пульсе</h2>
<p>Если вы уже загрузили копию проекта с помощью <strong>git clone</strong>, можете обновить ее до последней версии, используя</p>
<pre><code>$ git pull</code></pre>
<h2 id="_безотлагательная_публикация">Безотлагательная публикация</h2>
<p>Допустим, вы написали скрипт, которым хотите поделиться с другими. 
Можно просто предложить им скачивать его с вашего компьютера, но если 
они будут делать это когда вы дорабатываете его или добавляете 
экспериментальную функциональность, у них могут возникнуть проблемы. 
Очевидно, поэтому и существуют циклы разработки. Разработчики могут 
постоянно работать над проектом, но общедоступным они делают свой код 
только после того, как приведут его в приличный вид.</p>
<p>Чтобы сделать это с помощью Git, выполните в каталоге, где лежит ваш скрипт,</p>
<pre><code>$ git init
$ git add .
$ git commit -m "Первый релиз"</code></pre>
<p>Затем скажите вашим пользователям запустить</p>
<pre><code>$ git clone ваш.компьютер:/путь/до/скрипта</code></pre>
<p>чтобы загрузить ваш скрипт. Здесь подразумевается, что у них есть доступ по ssh. Если нет, запустите <strong>git daemon</strong> и скажите пользователям запустить эту команду вместо вышеприведенной:</p>
<pre><code>$ git clone git://ваш.компьютер/путь/до/скрипта</code></pre>
<p>С этих пор всякий раз, когда ваш скрипт готов к релизу, выполняйте</p>
<pre><code>$ git commit -a -m "Следующий релиз"</code></pre>
<p>и ваши пользователи смогут обновить свои версии, перейдя в каталог, с вашим скриптом и набрав</p>
<pre><code>$ git pull</code></pre>
<p>Ваши пользователи никогда не наткнутся на версию скрипта, которую вы не хотите им показывать.</p>
<h2 id="_что_я_сделал">Что я сделал?</h2>
<p>Выясните, какие изменения вы сделали со времени последнего коммита:</p>
<pre><code>$ git diff</code></pre>
<p>Или со вчерашнего дня:</p>
<pre><code>$ git diff "@{yesterday}"</code></pre>
<p>Или между определенной версией и версией, сделанной 2 коммита назад:</p>
<pre><code>$ git diff 1b6d "master~2"</code></pre>
<p>В каждом случае на выходе будет патч, который может быть применен с помощью <strong>git apply</strong>. Попробуйте также:</p>
<pre><code>$ git whatchanged --since="2 weeks ago"</code></pre>
<p>Часто вместо этого я использую для просмотра истории <a href="http://sourceforge.net/projects/qgit">qgit</a>, из-за приятного интерфейса, или <a href="http://jonas.nitro.dk/tig">tig</a> с текстовым интерфейсом, который хорошо работает через медленное соединение. Как вариант, установите веб-сервер, введите <strong>git instaweb</strong> и запустите любой веб-браузер.</p>
<h2 id="_упражнение">Упражнение</h2>
<p>Пусть A, B, C, D — четыре последовательных коммита, где В отличается 
от A лишь несколькими удаленными файлами. Мы хотим вернуть эти файлы в 
D. Как мы можем это сделать?</p>
<p>Существует как минимум три решения. Предположим, что мы находимся на D.</p>
<ol type="1">
<li><p>Разница между A и B — удаленные файлы. Мы можем создать патч, отражающий эти изменения, и применить его:</p>
<pre><code>$ git diff B A | git apply</code></pre></li>
<li><p>Поскольку в коммите A мы сохранили файлы, то можем восстановить их:</p>
<pre><code>$ git checkout A foo.c bar.h</code></pre></li>
<li><p>Мы можем рассматривать переход от A к B как изменения, которые хотим отменить:</p>
<pre><code>$ git revert B</code></pre></li>
</ol>
<p>Какой способ лучше? Тот, который вам больше нравится. С помощью Git 
легко получить желаемое, и часто существует много способов это сделать.</p>
<h1 id="_все_о_клонировании">Все о клонировании</h1>
<p>В старых системах управления версиями стандартная операция для 
получения файлов — это checkout. Вы получаете набор файлов в конкретном 
сохраненном состоянии.</p>
<p>В Git и других распределенных системах управления версиями 
стандартный способ — клонирование. Для получение файлов вы создаете 
«клон» всего хранилища. Другими словами, вы фактически создаете зеркало 
центрального сервера. При этом всё, что можно делать с основным 
хранилищем, можно делать и с локальным.</p>
<h2 id="_синхронизация_компьютеров">Синхронизация компьютеров</h2>
<p>Я вполне приемлю создание архивов или использование <strong>rsync</strong>
 для резервного копирования и простейшей синхронизации. Но я работаю то 
на ноутбуке, то на стационарном компьютере, которые могут никак между 
собой не взаимодействовать между этим.</p>
<p>Создайте хранилище Git и закоммитьте файлы на одном компьютере. А потом выполните на другом</p>
<pre><code>$ git clone первый.компьютер:/путь/к/файлам</code></pre>
<p>для создания второго экземпляра файлов и хранилища Git. С этого момента команды</p>
<pre><code>$ git commit -a
$ git pull другой.компьютер:/путь/к/файлам HEAD</code></pre>
<p>будут «втягивать» состояние файлов с другого компьютера на тот, где 
вы работаете. Если вы недавно внесли конфликтующие изменения в один и 
тот же файл, Git даст вам знать, и нужно будет сделать коммит заново 
после разрешения ситуации.</p>
<h2 id="_классическое_управление_исходным_кодом">Классическое управление исходным кодом</h2>
<p>Создайте хранилище Git для ваших файлов:</p>
<pre><code>$ git init
$ git add .
$ git commit -m "Начальный коммит"</code></pre>
<p>На центральном сервере создайте так называемое «голое» (bare) хранилище Git в неком каталоге:</p>
<pre><code>$ mkdir proj.git
$ cd proj.git
$ git init --bare
$  # вариант «в одну строчку»: GIT_DIR=proj.git git init</code></pre>
<p>Запустите Git-демон, если необходимо:</p>
<pre><code>$ git daemon --detach # возможно уже запущен</code></pre>
<p>Для создания нового пустого хранилища Git на публичных серверах 
следуйте их инструкциям. Обычно, нужно заполнить форму на веб-странице.</p>
<p>Отправьте ваши изменения в центральное хранилище вот так:</p>
<pre><code>$ git push git://центральный.сервер/путь/к/proj.git HEAD</code></pre>
<p>Для получения ваших исходников разработчик вводит</p>
<pre><code>$ git clone git://центральный.сервер/путь/к/proj.git</code></pre>
<p>После внесения изменений разработчик сохраняет изменения локально:</p>
<pre><code>$ git commit -a</code></pre>
<p>Для обновления до последней версии:</p>
<pre><code>$ git pull</code></pre>
<p>Любые конфликты слияния нужно разрешить и закоммитить:</p>
<pre><code>$ git commit -a</code></pre>
<p>Для выгрузки локальных изменений в центральное хранилище:</p>
<pre><code>$ git push</code></pre>
<p>Если на главном сервере были новые изменения, сделанные другими 
разработчиками, команда push не сработает. В этом случае разработчику 
нужно будет вытянуть к себе (pull) последнюю версию, разрешить возможные
 конфликты слияний и попробовать еще раз.</p>
<h2 id="_голые_bare_хранилища">Голые (bare) хранилища</h2>
<p>Голое (bare) хранилище называются так потому, что у него нет рабочего
 каталога. Оно содержит только файлы, которые обычно скрыты в 
подкаталоге .git. Другими словами, голое хранилище содержит историю 
изменений, но не содержит снимка какой-либо определенной версии.</p>
<p>Голое хранилище играет роль, похожую на роль основного сервера в 
централизованной системе управления версиями: это дом вашего проекта. 
Разработчики клонируют из него проект и закачивают в него свежие 
официальные изменения. Как правило, оно располагается на сервере, 
который не делает почти ничего кроме раздачи данных. Разработка идет в 
клонах, поэтому домашнее хранилище может обойтись и без рабочего 
каталога.</p>
<p>Многие команды Git не работают в голых хранилищах, если переменная 
среды GIT_DIR не содержит путь до хранилища и не указан параметр --bare.</p>
<h2 id="_push_или_pull">Push или pull?</h2>
<p>Зачем вводится команда push, вместо использования уже знакомой pull? 
Прежде всего, pull не работает в голых хранилищах, вместо нее нужно 
использовать команду fetch, которая будет рассмотрена позже. Но даже 
если держать на центральном сервере нормальное хранилище, использование 
команды pull в нем будет затруднительным. Нужно будет сначала войти на 
сервер интерактивно и сообщить команде pull адрес машины, с которой мы 
хотим забрать изменения. Этому могут мешать сетевые брандмауэры 
(firewall), но в первую очередь: что если у нас нет интерактивного 
доступа к серверу?</p>
<p>Тем не менее, не рекомендутся push-ить в хранилище помимо этого 
случая — из-за путаницы, которая может возникнуть, если у целевого 
хранилища есть рабочий каталог.</p>
<p>Короче говоря, пока изучаете Git, push-те только в голые хранилища. В остальных случаях pull-те.</p>
<h2 id="_создание_форка_проекта">Создание форка проекта</h2>
<p>Не нравится путь развития проекта? Думаете, можете сделать лучше? Тогда на вашем сервере выполните</p>
<pre><code>$ git clone git://основной.сервер/путь/к/файлам</code></pre>
<p>Теперь расскажите всем о форке (ответвлении, прим. пер.) проекта на вашем сервере.</p>
<p>Позже вы сможете в любой момент втянуть к себе изменения из первоначального проекта:</p>
<pre><code>$ git pull</code></pre>
<h2 id="_максимальные_бэкапы">Максимальные бэкапы</h2>
<p>Хотите иметь множество защищенных, географически разнесенных запасных
 архивов? Если в вашем проекте много разработчиков, ничего делать не 
нужно! Каждый клон — это и есть резервная копия; не только текущего 
состояния, но и всей истории изменений проекта. Благодаря 
криптографическому хешированию, повреждение какого-либо из клонов будет 
обнаружено при первой же попытке взаимодействия с другими клонами.</p>
<p>Если ваш проект не такой популярный, найдите как можно больше серверов для размещения клонов.</p>
<p>Особо беспокоящимся рекомендуется всегда записывать самый последний 
20-байтный SHA1 хеш HEAD в каком-нибудь безопасном месте. Оно должно 
быть безопасным, а не тайным. Например, хороший вариант — публикация в 
газете, потому что атакующему сложно изменить каждый экземпляр газеты.</p>
<h2 id="_многозадачность_со_скоростью_света">Многозадачность со скоростью света</h2>
<p>Скажем, вы хотите работать над несколькими функциями параллельно. Тогда закоммитьте ваши изменения и запустите</p>
<pre><code>$ git clone . /некий/новый/каталог</code></pre>
<p>Благодаря <a href="http://ru.wikipedia.org/wiki/%D0%B6%D1%91%D1%81%D1%82%D0%BA%D0%B0%D1%8F_%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0">жёстким ссылкам</a> создание локального клона требует меньше времени и места, чем простое копирование.</p>
<p>Теперь вы можете работать с двумя независимыми функциями 
одновременно. Например, можно редактировать один клон, пока другой 
компилируется. В любой момент можно сделать коммит и вытянуть изменения 
из другого клона:</p>
<pre><code>$ git pull /другой/клон HEAD</code></pre>
<h2 id="_партизанское_управление_версиями">Партизанское управление версиями</h2>
<p>Вы работаете над проектом, который использует другую систему 
управления версиями, и вам очень не хватает Git? Тогда создайте 
хранилище Git в своем рабочем каталоге:</p>
<pre><code>$ git init
$ git add .
$ git commit -m "Начальный коммит"</code></pre>
<p>затем склонируйте его:</p>
<pre><code>$ git clone . /некий/новый/каталог</code></pre>
<p>Теперь перейдите в этот новый каталог и работайте в нем вместо 
основного, используя Git в свое удовольствие. В какой-то момент вам 
понадобиться синхронизировать изменения со всеми остальными — тогда 
перейдите в изначальный каталог, синхронизируйте его с помощью другой 
системы управления версиями и наберите</p>
<pre><code>$ git add .
$ git commit -m "Синхронизация с остальными"</code></pre>
<p>Теперь перейдите в новый каталог и запустите</p>
<pre><code>$ git commit -a -m "Описание моих изменений"
$ git pull</code></pre>
<p>Процедура передачи изменений остальным зависит от другой системы 
управления версиями. Новый каталог содержит файлы с вашими изменениями. 
Запустите команды другой системы управления версиями, необходимые для 
загрузки файлов в центральное хранилище.</p>
<p>Subversion (вероятно, наилучшая централизованная система управления 
версиями) используется неисчислимым множеством проектов. Команда <strong>git svn</strong> автоматизирует описанный процесс для хранилищ Subversion, а также может быть использована для <a href="http://google-opensource.blogspot.com/2008/05/export-git-project-to-google-code.html">экспорта проекта Git в хранилище Subversion</a>.</p>
<h2 id="_mercurial">Mercurial</h2>
<p>Mercurial — похожая система управления версиями, которая может 
работать в паре с Git практически без накладок. С расширением hg-git 
пользователь Mercurial может без каких либо потерь push-ить и pull-ить 
из хранилища Git.</p>
<p>Получить hg-git можно с помощью Git:</p>
<pre><code>$ git clone git://github.com/schacon/hg-git.git</code></pre>
<p>или Mercurial:</p>
<pre><code>$ hg clone http://bitbucket.org/durin42/hg-git/</code></pre>
<p>К сожалению, мне неизвестен аналогичное расширение для Git. Поэтому я
 рекомендую использовать Git, а не Mercurial, для центрального 
хранилища, даже если вы предпочитаете Mercurial. Для проектов, 
использующих Mercurial, обычно какой-нибудь доброволец поддерживает 
параллельное хранилище Git для привлечения пользователей последнего, 
тогда как проекты, использующие Git, благодаря hg-git автоматически 
доступны пользователям Mercurial.</p>
<p>Хотя расширение может сконвертировать хранилище Mercurial в Git путем
 push'а в пустое хранилище, эту задачу легче решить, используя сценарий 
hg-fast-export.sh, доступный как</p>
<pre><code>$ git clone git://repo.or.cz/fast-export.git</code></pre>
<p>Для преобразования выполните в пустом каталоге</p>
<pre><code>$ git init
$ hg-fast-export.sh -r /hg/repo</code></pre>
<p>после добавления сценария в ваш $PATH.</p>
<h2 id="_bazaar">Bazaar</h2>
<p>Упомянем вкратце Bazaar, так как это самая популярная свободная 
распределенная система управления версиями после Git и Mercurial.</p>
<p>Bazaar относительно молод, поэтому у него есть преимущество идущего 
следом. Его проектировщики могут учиться на ошибках предшественников и 
избавиться от исторически сложившихся неровностей. Кроме того, его 
разработчики заботятся о переносимости и взаимодействии с другими 
системами управления версиями.</p>
<p>Расширение bzr-git позволяет (в какой-то степени) пользователям 
Bazaar работать с хранилищами Git. Программа tailor конвертирует 
хранилища Bazaar в Git и может делать это с накоплением, тогда как 
bzr-fast-export хорошо приспособлена для разовых преобразований.</p>
<h2 id="_почему_я_использую_git">Почему я использую Git</h2>
<p>Изначально я выбрал Git потому, что слышал, что он в состоянии 
справиться с совершенно неуправляемыми исходными текстами ядра Linux. Я 
никогда не ощущал потребности сменить его на что-то другое. Git работает
 замечательно и мне еще только предстоит напороться на его недостатки. 
Так как я в основном использую Linux, проблемы на других системах меня 
не касаются.</p>
<p>Я также предпочитаю программы на C и сценарии на bash исполняемым 
файлам вроде сценариев на Python-е: у них меньше зависимостей, и я 
привык к быстрому выполнению.</p>
<p>Я думал о том, как можно улучшить Git, вплоть до того, чтобы написать
 собственный инструмент, похожий на Git; но только как академическое 
упражнение. Завершив проект, я бы все равно продолжил пользоваться Git, 
потому что выигрыш слишком мал, чтобы оправдать использование 
самодельной системы.</p>
<p>Естественно, ваши потребности и пожелания вероятно отличаются от моих
 и вы, возможно, лучше уживетесь с другой системой. И всё же вы не 
слишком ошибетесь, используя Git.</p>
<h1 id="_чудеса_ветвления">Чудеса ветвления</h1>
<p>Возможности мгновенного ветвления и слияния — самые замечательный особенности Git.</p>
<p><strong>Задача</strong>: внешние факторы неизбежно влекут 
переключение внимания. Серьезная ошибка в уже выпущенной версии 
обнаруживается без предупреждения. Срок сдачи определённой 
функциональности приближается. Разработчик, помощь которого нужна вам в 
работе над ключевой частью проекта, собирается в отпуск. Одним словом, 
вам нужно срочно бросить все, над чем вы трудитесь в настоящий момент, и
 переключиться на совершенно другие задачи.</p>
<p>Прерывание хода ваших мыслей может серьезно снизить эффективность 
работы, и чем сложнее переключение между процессами, тем больше будет 
потеря. При централизованном управлении версиями мы вынуждены скачивать 
свежую рабочую копию с центрального сервера. Распределенная система 
лучше: мы можем клонировать нужную версию локально.</p>
<p>Однако клонирование все же предполагает копирование всего рабочего 
каталога, как и всей истории изменений до настоящего момента. Хотя Git и
 снижает затратность этого действия за счет возможности совместного 
использования файлов и жестких ссылок, но все файлы проекта придется 
полностью воссоздать в новом рабочем каталоге.</p>
<p><strong>Решение</strong>: у Git есть более удобный инструмент для 
таких случаев, который сэкономит и время, и дисковое пространство по 
сравнению с клонированием — это <strong>git branch</strong> (branch — ветка, прим. пер.).</p>
<p>Этим волшебным словом файлы в вашем каталоге мгновенно преобразуются 
от одной версии к другой. Это изменение позволяет сделать намного 
больше, чем просто вернуться назад или продвинуться вперед в истории. 
Ваши файлы могут изменится с последней выпущенной версии на 
экспериментальную, с экспериментальной — на текущую версию в разработке,
 с нее — на версию вашего друга и так далее.</p>
<h2 id="_кнопка_босса">Кнопка босса</h2>
<p>Играли когда-нибудь в одну из таких игр, где при нажатии определеной 
клавиши («кнопки босса»), на экране мгновенно отображается таблица или 
что-то вроде того? То есть, если в офис зашел начальник, а вы играете в 
игру, вы можете быстро ее скрыть.</p>
<p>В каком-нибудь каталоге:</p>
<pre><code>$ echo "Я хитрее моего босса" &gt; myfile.txt
$ git init
$ git add .
$ git commit -m "Начальный коммит"</code></pre>
<p>Мы создали хранилище Git, содержащее один текстовый файл с определенным сообщением. Теперь выполните</p>
<pre><code>$ git checkout -b boss # вероятно, это последнее изменение
$ echo "Мой босс умнее меня" &gt; myfile.txt
$ git commit -a -m "Другой коммит"</code></pre>
<p>Это выглядит так, будто мы только что перезаписали файл и сделали коммит. Но это иллюзия. Наберите</p>
<pre><code>$ git checkout master # переключиться на оригинальную версию файла</code></pre>
<p>Вуаля! Текстовый файл восстановлен. А если босс решит сунуть нос в этот каталог, запустите</p>
<pre><code>$ git checkout boss # перейти на версию, подходящую для глаз босса</code></pre>
<p>Вы можете переключаться между двумя версиями этого файла так часто, как вам хочется и делать коммиты каждой из них независимо.</p>
<h2 id="_грязная_работа">Грязная работа</h2>
<p>Допустим, вы работаете над некой функцией, и вам зачем-то 
понадобилось вернуться на три версии назад и временно добавить несколько
 операторов вывода, чтобы посмотреть как что-либо работает. Тогда 
введите</p>
<pre><code>$ git commit -a
$ git checkout HEAD~3</code></pre>
<p>Теперь вы можете добавлять временный черновой код в любых местах. 
Можно даже закоммитить эти изменения. Когда закончите, выполните</p>
<pre><code>$ git checkout master</code></pre>
<p>чтобы вернуться к исходной работе. Заметьте, что любые изменения, не внесенные в коммит, будут перенесены.</p>
<p>А что, если вы все-таки хотели сохранить временные изменения? Запросто:</p>
<pre><code>$ git checkout -b dirty</code></pre>
<p>а затем сделайте коммит перед возвращением в ветку master. Всякий 
раз, когда вы захотите вернуться к черновым изменениям, просто выполните</p>
<pre><code>$ git checkout dirty</code></pre>
<p>Мы говорили об этой команде в одной из предыдущих глав, когда 
обсуждали загрузку старых состояний. Теперь у нас перед глазами полная 
картина: файлы изменились к нужному состоянию, но мы должны покинуть 
главную ветку. Любые коммиты, сделанные с этого момента, направят файлы 
по другому пути, к которому можно будет вернуться позже.</p>
<p>Другими словами, после переключения на более старое состояние Git 
автоматически направляет вас по новой безымянной ветке, которой можно 
дать имя и сохранить ее с помощью <strong>git checkout -b</strong>.</p>
<h2 id="_быстрые_исправления">Быстрые исправления</h2>
<p>Ваша работа в самом разгаре, когда вдруг выясняется, что нужно все 
бросить и исправить только что обнаруженную ошибку в коммите «1b6d…»:</p>
<pre><code>$ git commit -a
$ git checkout -b fixes 1b6d</code></pre>
<p>После исправления ошибки сделайте</p>
<pre><code>$ git commit -a -m "Ошибка исправлена"
$ git checkout master</code></pre>
<p>и вернитесь к работе над вашими исходными задачами.</p>
<p>Вы можете даже «влить» только что сделанное исправление ошибки в основную ветку:</p>
<pre><code>$ git merge fixes</code></pre>
<h2 id="_слияния">Слияния</h2>
<p>В некоторых системах управления версиями создавать ветки легко, а вот
 сливать их воедино трудно. В Git слияние столь тривиально, что вы 
можете его не заметить.</p>
<p>На самом деле мы сталкивались со слияниями уже давно. Команда <strong>pull</strong>
 по сути получает коммиты, а затем сливает их с вашей текущей веткой. 
Если у вас нет локальных изменений, слияние произойдет само собой, как 
вырожденный случай вроде получения последней версии в централизованной 
системе управления версиями. Если же у вас есть локальные изменения, Git
 автоматически произведет слияние и сообщит о любых конфликтах.</p>
<p>Обычно у коммита есть один «родитель», а именно предыдущий коммит. 
Слияние веток приводит к коммиту как минимум с двумя родителями. Отсюда 
возникает вопрос: к какому коммиту на самом деле отсылает HEAD~10? 
Коммит может иметь несколько родителей, так за которым из них следовать 
далее?</p>
<p>Оказывается, такая запись всегда выбирает первого родителя. Это 
хороший выбор, потому что текущая ветка становятся первым родителем во 
время слияния. Часто вас интересуют только изменения, сделанные вами в 
текущей ветке, а не те, которые влились из других веток.</p>
<p>Вы можете обращаться к конкретному родителю с помощью символа «^». 
Например, чтобы показать запись в журнале от второго родителя, наберите</p>
<pre><code>$ git log HEAD^2</code></pre>
<p>Для первого родителя номер можно опустить. Например, чтобы показать разницу с первым родителем, введите</p>
<pre><code>$ git diff HEAD^</code></pre>
<p>Вы можете сочетать такую запись с другими. Например,</p>
<pre><code>$ git checkout 1b6d^^2~10 -b ancient</code></pre>
<p>создаст новую ветку «ancient» («древняя», прим. пер.), отражающую 
состояние на десять коммитов назад от второго родителя первого родителя 
коммита, начинающегося с 1b6d.</p>
<h2 id="_непрерывный_рабочий_процесс">Непрерывный рабочий процесс</h2>
<p>В производстве техники часто бывает, что второй шаг плана должен 
ждать завершения первого шага. Автомобиль, нуждающийся в ремонте, может 
тихо стоять в гараже до прибытия с завода конкретной детали. Прототип 
может ждать производства чипа, прежде чем разработка будет продолжена.</p>
<p>И в разработке ПО может быть то же. Вторая порция новой 
функциональности может быть вынуждена ожидать выпуска и тестирования 
первой части. Некоторые проекты требуют проверки вашего кода перед его 
принятием, так что вы должны дождаться утверждения первой части, прежде 
чем начинать вторую.</p>
<p>Благодаря безболезненным ветвлению и слиянию, мы можем изменить 
правила и работать над второй частью до того, как первая официально 
будет готова. Допустим, вы закоммитили первую часть и выслали ее на 
проверку. Скажем, вы в ветке master. Теперь смените ветку:</p>
<pre><code>$ git checkout -b part2 # часть2</code></pre>
<p>Затем работайте над второй частью, попутно внося коммиты ваших 
изменений. Человеку свойственно ошибаться, и часто вы хотите вернуться и
 поправить что-то в первой части. Если вы везучи или очень искусны, 
можете пропустить эти строки.</p>
<pre><code>$ git checkout master  # Возвращаемся к первой части.
$ вносим_исправления
$ git commit -a        # Фиксируем изменения
$ git checkout part2   # Возвращаемся ко второй части.
$ git merge master     # Вливаем сделанные исправления.</code></pre>
<p>В конечном счете, первая часть утверждена:</p>
<pre><code>$ git checkout master  # Возвращаемся к первой части.
$ отправка файлов        # Выпускаем в мир!
$ git merge part2      # Вливаем вторую часть.
$ git branch -d part2  # Удаляем ветку part2.</code></pre>
<p>Теперь вы снова в ветке master, а вторая часть — в вашем рабочем каталоге.</p>
<p>Этот прием легко расширить на любое количество частей. Столь же легко
 сменить ветку задним числом. Предположим, вы слишком поздно обнаружили,
 что должны были создать ветку семь коммитов назад. Тогда введите:</p>
<pre><code>$ git branch -m master part2 # Переименовываем ветку master в part2.
$ git branch master HEAD~7   # Создаем новую ветку master семью коммитами выше.</code></pre>
<p>Теперь ветка master содержит только первую часть, а ветка part2 — всё
 остальное. В последней мы и находимся. Мы создали ветку master, не 
переключаясь на нее, потому что хотим продолжить работу над part2. Это 
непривычно: до сих пор мы переключались на ветки сразу же после их 
создания, вот так:</p>
<pre><code>$ git checkout HEAD~7 -b master  # Создаем ветку и переключаемся на нее.</code></pre>
<h2 id="_изменяем_состав_смеси">Изменяем состав смеси</h2>
<p>Предположим, вам нравится работать над всеми аспектами проекта в 
одной и той же ветке. Вы хотите закрыть свой рабочий процесс от других, 
чтобы все видели ваши коммиты только после того, как они будут хорошо 
оформлены. Создайте пару веток:</p>
<pre><code>$ git branch sanitized    # Создаем ветку для очищенных коммитов.
$ git checkout -b medley  # Создаем ветку для работы и переключаемся на нее.</code></pre>
<p>Далее делайте всё что нужно: исправляйте ошибки, добавляйте новые 
функции, добавляйте временный код и так далее, при этом почаще выполняя 
коммиты. После этого</p>
<pre><code>$ git checkout sanitized
$ git cherry-pick medley^^</code></pre>
<p>применит коммит «пра-родителя» головы ветки «medley» к ветке 
«sanitized». Правильно подбирая элементы, вы сможете создать ветку, в 
которой будет лишь окончательный код, а связанные между собой коммиты 
будут собраны вместе.</p>
<h2 id="_управление_ветками">Управление Ветками</h2>
<p>Для просмотра списка всех веток наберите</p>
<pre><code>$ git branch</code></pre>
<p>По умолчанию вы начинаете с ветки под названием «master». Кому-то 
нравится оставлять ветку «master» нетронутой и создавать новые ветки со 
своими изменениями.</p>
<p>Опции <strong>-d</strong> и <strong>-m</strong> позволяют удалять и перемещать (переименовывать) ветки. Смотрите <strong>git help branch</strong>.</p>
<p>Ветка «master» — это удобная традиция. Другие могут предполагать, что
 в вашем хранилище есть ветка с таким именем и что она содержит 
официальную версию проекта. Хотя вы можете переименовать или уничтожить 
ветку «master», лучше соблюсти общее соглашение.</p>
<h2 id="_временные_ветки">Временные Ветки</h2>
<p>Через какое-то время вы можете обнаружить, что создаете множество 
временных веток для одной и той же краткосрочной цели: каждая такая 
ветка всего лишь сохраняет текущее состояние, чтобы вы могли вернуться 
назад и исправить серьезную ошибку или сделать что-то еще.</p>
<p>Это похоже на то, как вы переключаете телевизионные каналы, чтобы 
посмотреть что показывают по другим. Но вместо того, чтобы нажать на 
пару кнопок, вам нужно создавать, выбирать (checkout), сливать (merge) а
 затем удалять временные ветки. К счастью, в Git есть сокращенная 
команда, столь же удобная, как пульт дистанционного управления.</p>
<pre><code>$ git stash</code></pre>
<p>Эта команда сохранит текущее состояние в во временном месте 
(«тайнике», stash) и востановит предыдущее состояние. Ваш каталог 
становиться точно таким, каким был до начала редактирования, и вы можете
 исправить ошибки, загрузить удаленные изменения и тому подобное. Когда 
вы хотите вернуться назад в состояние «тайника», наберите:</p>
<pre><code>$ git stash apply # Возможно, понадобится устранить возникшие конфликты.</code></pre>
<p>Можно создавать несколько тайников, используя их по-разному. Смотрите <strong>git help stash</strong>. Как вы могли догадаться, Git оставляет ветки «за кадром» при выполнении этого чудесного приема.</p>
<h2 id="_работайте_как_вам_нравится">Работайте как вам нравится</h2>
<p>Возможно, вы сомневаетесь, стоят ли ветки таких хлопот. В конце 
концов, клоны почти столь же быстрые и вы можете переключаться между 
ними с помощью <strong>cd</strong> вместо загадочных команд Git.</p>
<p>Посмотрим на веб-браузеры. Зачем нужна поддержка вкладок вдобавок к 
окнам? Поддержка и тех, и других позволяет приспособиться к широкому 
разнообразию стилей работы. Некоторым пользователям нравится держать 
открытым единственное окно и использовать вкладки для множества 
веб-страниц. Другие могут впасть в другую крайность: множество окон без 
вкладок вообще. Третьи предпочтут нечто среднее.</p>
<p>Ветки похожи на вкладки для рабочего каталога, а клоны — на новые 
окна браузера. Эти операции быстры и выполняются локально, так почему бы
 не поэкспериментировать и не найти наиболее удобную для себя 
комбинацию? Git позволяет работать в точности так, как вам нравится.</p>
<h1 id="_уроки_истории">Уроки истории</h1>
<p>Вследствие распределенной природы Git, историю изменений можно легко 
редактировать. Однако, если вы вмешиваетесь в прошлое, будьте осторожны:
 изменяйте только ту часть истории, которой владеете вы и только вы. 
Иначе, как народы вечно выясняют, кто же именно совершил и какие 
бесчинства, так и у вас будут проблемы с примирением при попытке 
совместить разные деревья истории.</p>
<p>Некоторые разработчики убеждены, что история должна быть неизменна со
 всеми огрехами и прочим. Другие считают, что деревья нужно делать 
презентабельными перед выпуском их в публичный доступ. Git учитывает оба
 мнения. Переписывание истории, как и клонирование, ветвление и слияние,
 — лишь еще одна возможность, которую дает вам Git. Разумное ее 
использование зависит только от вас.</p>
<h2 id="_оставаясь_корректным">Оставаясь корректным</h2>
<p>Только что сделали коммит и поняли, что должны были ввести другое описание? Запустите</p>
<pre><code>$ git commit --amend</code></pre>
<p>чтобы изменить последнее описание. Осознали, что забыли добавить файл? Запустите <strong>git add</strong>, чтобы это сделать, затем выполните вышеуказанную команду.</p>
<p>Захотелось добавить еще немного изменений в последний коммит? Так сделайте их и запустите</p>
<pre><code>$ git commit --amend -a</code></pre>
<h2 id="_и_кое_что_еще">…И кое-что еще</h2>
<p>Давайте представим, что предыдущая проблема на самом деле в десять 
раз хуже. После длительной работы вы сделали ряд коммитов; но вы не 
очень-то довольны тем, как они организованы, и кое-какие описания 
коммитов надо бы слегка переформулировать. Тогда запустите</p>
<pre><code>$ git rebase -i HEAD~10</code></pre>
<p>и последние десять коммитов появятся в вашем любимом редакторе (задается переменной окружения $EDITOR). Например:</p>
<pre><code>pick 5c6eb73 Добавил ссылку repo.or.cz
pick a311a64 Переставил аналогии в «Работай как хочешь»
pick 100834f Добавил цель для push в Makefile</code></pre>
<p>Теперь вы можете:</p>
<ul>
<li><p>Убирать коммиты, удаляя строки.</p></li>
<li><p>Менять порядок коммитов, переставляя строки.</p></li>
<li><p>Заменять «pick» на:</p>
<ul>
<li><p>«edit» для внесения правок в коммиты;</p></li>
<li><p>«reword» для изменения описания в журнале;</p></li>
<li><p>«squash» для слияния коммита с предыдущим;</p></li>
<li><p>«fixup», чтобы слить коммит с предыдущим, отбросив его описание.</p></li>
</ul></li>
</ul>
<p>Сохраните файл и закройте редактор. Если вы отметили коммит для исправлений, запустите</p>
<pre><code>$ git commit --amend</code></pre>
<p>Если нет, запустите</p>
<pre><code>$ git rebase --continue</code></pre>
<p>Одним словом, делайте коммиты как можно раньше и как можно чаще — вы всегда сможете навести порядок при помощи rebase.</p>
<h2 id="_локальные_изменения_сохраняются">Локальные изменения сохраняются</h2>
<p>Предположим, вы работаете над активным проектом. За какое-то время вы
 делаете несколько коммитов, затем синхронизируетесь с официальным 
деревом через слияние. Цикл повторяется несколько раз, пока вы не будете
 готовы влить изменения в центральное дерево.</p>
<p>Однако теперь история изменений в локальном клоне Git представляет 
собой кашу из ваших и официальных изменений. Вам бы хотелось видеть все 
свои изменения непрерывной линией, а затем — все официальные изменения.</p>
<p>Это работа для команды <strong>git rebase</strong>, описанной выше. Зачастую, имеет смысл использовать флаг <strong>--onto</strong> и убрать переплетения.</p>
<p>Также смотрите <strong>git help rebase</strong> для получения 
подробных примеров использования этой замечательной команды. Вы можете 
расщеплять коммиты. Вы можете даже переупорядочивать ветки.</p>
<h2 id="_переписывая_историю">Переписывая историю</h2>
<p>Время от времени вам может понадобиться в системе управления версиями
 аналог «замазывания» людей на официальных фотографиях, как бы 
стирающего их из истории в духе сталинизма. Например, предположим, что 
мы уже собираемся выпустить релиз проекта, но он содержит файл, который 
не должен стать достоянием общественности по каким-то причинам. 
Возможно, я сохранил номер своей кредитки в текстовый файл и случайно 
добавил его в проект. Удалить файл недостаточно: он может быть доступен 
из старых коммитов. Нам надо удалить файл из всех ревизий:</p>
<pre><code>$ git filter-branch --tree-filter 'rm совершенно/секретный/файл' HEAD</code></pre>
<p>Смотрите <strong>git help filter-branch</strong>, где обсуждается этот пример и предлагается более быстрый способ решения. Вообще, <strong>filter-branch</strong> позволяет изменять существенные части истории при помощи одной-единственной команды.</p>
<p>После этой команды каталог <code>.git/refs/original</code> будет 
описывать состояние, которое было до ее вызова. Убедитесь, что команда 
filter-branch сделала то, что вы хотели, и если хотите опять 
использовать эту команду, удалите этот каталог.</p>
<p>И, наконец, замените клоны вашего проекта исправленной версией, если собираетесь в дальнейшем с ними взаимодействовать.</p>
<h2 id="_создавая_историю">Создавая Историю</h2>
<p>Хотите перевести проект под управление Git? Если сейчас он находится 
под управлением какой-либо из хорошо известных систем управления 
версиями, то вполне вероятно, что кто-нибудь уже написал необходимые 
скрипты для экспорта всей истории проекта в Git.</p>
<p>Если нет, то смотрите в сторону команды <strong>git fast-import</strong>,
 которая считывает текстовый ввод в специальном формате для создания 
истории Git с нуля. Обычно скрипт, использующий эту команду, бывает 
слеплен наспех для единичного запуска, переносящего весь проект за один 
раз.</p>
<p>В качестве примера вставьте такие строки во временный файл, вроде <em>/tmp/history</em>:</p>
<pre><code>commit refs/heads/master
committer Alice &lt;alice@example.com&gt; Thu, 01 Jan 1970 00:00:00 +0000
data &lt;&lt;EOT
Начальный коммит.
EOT

M 100644 inline hello.c
data &lt;&lt;EOT
#include &lt;stdio.h&gt;

int main() {
  printf("Hello, world!\n");
  return 0;
}
EOT

commit refs/heads/master
committer Bob &lt;bob@example.com&gt; Tue, 14 Mar 2000 01:59:26 -0800
data &lt;&lt;EOT
Заменен printf() на write()
EOT

M 100644 inline hello.c
data &lt;&lt;EOT
#include &lt;unistd.h&gt;

int main() {
  write(1, "Hello, world!\n", 14);
  return 0;
}
EOT</code></pre>
<p>Затем создайте хранилище Git из этого временного файла при помощи команд:</p>
<p>$ mkdir project; cd project; git init $ git fast-import --date-format=rfc2822 &lt; /tmp/history</p>
<p>Вы можете извлечь последнюю версию проекта с помощью</p>
<pre><code>$ git checkout master .</code></pre>
<p>Команда <strong>git fast-export</strong> преобразует любое хранилище в формат, понятныый команде <strong>git fast-import</strong>.
 Ее вывод можно использовать как образец для написания скриптов 
преобразования, или для переноса хранилищ в понятном человеку формате. 
Конечно, с помощью этих команд можно пересылать хранилища текстовых 
файлов через каналы передачи текста.</p>
<h2 id="_когда_же_все_пошло_не_так">Когда же все пошло не так?</h2>
<p>Вы только что обнаружили, что кое-какой функционал вашей программы не
 работает, но вы совершенно отчетливо помните, что он работал всего 
несколько месяцев назад. Ох… Откуда же взялась ошибка? Вы же это 
проверяли сразу как разработали.</p>
<p>В любом случае, уже слишком поздно. Однако, если вы фиксировали свои 
изменения достаточно часто, то Git сможет точно указать проблему:</p>
<pre><code>$ git bisect start
$ git bisect bad HEAD
$ git bisect good 1b6d</code></pre>
<p>Git извлечет состояние ровно посередине. Проверьте работает ли то, что сломалось, и если все еще нет,</p>
<pre><code>$ git bisect bad</code></pre>
<p>Если же работает, то замените «bad» на «good». Git снова переместит 
вас в состояние посередине между «хорошей» и «плохой» ревизиями, сужая 
круг поиска. После нескольких итераций, этот двоичный поиск приведет вас
 к тому коммиту, на котором возникла проблема. После окончания 
расследования, вернитесь в исходное состояние командой</p>
<pre><code>$ git bisect reset</code></pre>
<p>Вместо ручного тестирования каждого изменения автоматизируйте поиск, запустив</p>
<pre><code>$ git bisect run my_script</code></pre>
<p>По возвращаемому значению заданной команды, обычно одноразового 
скрипта, Git будет отличать хорошее состояние от плохого. Скрипт должен 
вернуть 0, если нынешний коммит хороший; 125, если его надо пропустить; и
 любое другое число от 1 до 127, если он плохой. Отрицательное 
возвращаемое значение прерывает команду bisect.</p>
<p>Вы можете сделать многим больше: страница помощи поясняет, как 
визуализировать bisect, проанализировать или воспроизвести ее журнал, 
или исключить заведомо хорошие изменения для ускорения поиска.</p>
<h2 id="_из_за_кого_все_пошло_не_так">Из-за кого все пошло не так?</h2>
<p>Как и во многих других системах управления версиями, в Git есть команда blame (ответственность, прим. пер.):</p>
<pre><code>$ git blame bug.c</code></pre>
<p>Она снабжает каждую строку выбранного файла примечаниями, 
раскрывающими, кто и когда последним ее редактировал. В отличие же от 
многих других систем управления версиями, эта операция происходит без 
соединения с сетью, выбирая данные с локального диска.</p>
<h2 id="_личный_опыт">Личный опыт</h2>
<p>В централизованных системах управления версиями изменения истории — 
достаточно сложная операция, и доступна она лишь администраторам. 
Клонирование, ветвление и слияние невозможны без взаимодействия по сети.
 Так же обстоят дела и с базовыми операциями, такими как просмотр 
истории или фиксация изменений. В некоторых системах сетевое соединение 
требуется даже для просмотра собственных изменений, или открытия файла 
для редактирования.</p>
<p>Централизованные системы исключают возможность работы без сети и 
требуют более дорогой сетевой инфраструктуры, особенно с увеличением 
количества разработчиков. Что важнее, все операции происходят медленнее,
 обычно до такой степени, что пользователи избегают пользоваться 
«продвинутыми» командами без крайней необходимости. В радикальных 
случаях это касается даже большинства базовых команд. Когда пользователи
 вынуждены запускать медленные команды, производительность страдает 
из-за прерываний рабочего процесса.</p>
<p>Я испытал этот феномен на себе. Git был моей первой системой 
управления версиями. Я быстро привык к нему и стал относится к его 
возможностям как к должному. Я предполагал, что и другие системы похожи 
на него: выбор системы управления версиями не должен отличаться от 
выбора текстового редактора или браузера.</p>
<p>Когда немного позже я был вынужден использовать централизованную 
систему управления версиями, я был шокирован. Ненадежное 
интернет-соединение не имеет большого значения при использовании Git, но
 делает разработку невыносимой, когда от него требуют надежности как у 
жесткого диска. Вдобавок я обнаружил, что стал избегать некоторых команд
 из-за задержек в их выполнении, что помешало мне следовать 
предпочтительному рабочему процессу.</p>
<p>Когда мне было нужно запустить медленную команду, нарушение хода моих
 мыслей оказывало несоизмеримый ущерб разработке. Ожидая окончания связи
 с сервером, я вынужден был заниматься чем-то другим, чтобы скоротать 
время; например, проверкой почты или написанием документации. К тому 
времени, как я возвращался к первоначальной задаче, выполнение команды 
было давно закончено, но мне приходилось тратить уйму времени, чтоб 
вспомнить, что именно я делал. Люди не очень приспособлены для 
переключения между задачами.</p>
<p>Кроме того, есть интересный эффект «трагедии общественных ресурсов»: 
предвидя будущую перегруженность сети, некоторые люди в попытке 
предотвратить грядущие задержки начинают использовать более широкие 
каналы, чем им реально требуется для текущих задач. Суммарная активность
 увеличивает загрузку сети, поощряя людей задействовать всё более 
высокоскоростные каналы для предотвращения еще больших задержек.</p>
<h1 id="_многопользовательский_git">Многопользовательский Git</h1>
<p>Сначала я использовал Git для личного проекта, в котором был 
единственным разработчиком. Среди команд, относящихся к распределенным 
свойствам Git, мне были нужны только <strong>pull</strong> и <strong>clone</strong>, чтобы хранить один и тот же проект в разных местах.</p>
<p>Позднее я захотел опубликовать свой код при помощи Git и включать 
изменения помощников. Мне пришлось научиться управлять проектами, в 
которых участвуют многие люди по всему миру. К счастью, в этом сильная 
сторона Git и, возможно, сам смысл его существования.</p>
<h2 id="_кто_я">Кто я?</h2>
<p>Каждый коммит содержит имя автора и адрес электронной почты, которые выводятся командой <strong>git log</strong>. По умолчанию Git использует системные настройки для заполнения этих полей. Чтобы установить их явно, введите</p>
<pre><code>  $ git config --global user.name "John
Doe"
  $ git config --global user.email
johndoe@example.com</code></pre>
<p>Чтобы установить эти параметры только для текущего хранилища, опустите флаг --global.</p>
<h2 id="_git_через_ssh_http">Git через SSH, HTTP</h2>
<p>Предположим, у вас есть SSH доступ к веб-серверу, но Git не 
установлен. Git может связываться через HTTP, хотя это и менее 
эффективно, чем его собственный протокол.</p>
<p>Скачайте, скомпилируйте, установите Git в вашем аккаунте; создайте хранилище в каталоге, доступном через web:</p>
<pre><code> $ GIT_DIR=proj.git git init
 $ cd proj.git
 $ git --bare update-server-info
 $ cp hooks/post-update.sample
hooks/post-update</code></pre>
<p>Для старых версий Git команда копирования не сработает, и вы должны будете запустить</p>
<pre><code>$ chmod a+x hooks/post-update</code></pre>
<p>Теперь вы можете публиковать свои последние правки через SSH с любого клона:</p>
<pre><code> $ git push
веб.сервер:/путь/к/proj.git master</code></pre>
<p>и кто угодно сможет взять ваш проект с помощью</p>
<pre><code>$ git clone http://веб.сервер/proj.git</code></pre>
<h2 id="_git_через_что_угодно">Git через что угодно</h2>
<p>Хотите синхронизировать хранилища без серверов или вообще без 
сетевого подключения? Вынуждены импровизировать на ходу в непредвиденной
 ситуации? Мы видели, как <a href="#makinghistory"><strong>git fast-export</strong> и <strong>git fast-import</strong> могут преобразовать хранилища в один файл и обратно</a>.
 Посредством обмена такими файлами мы можем переносить хранилища git 
любыми доступными средствами, но есть более эффективный инструмент: <strong>git bundle</strong>.</p>
<p>Отправитель создает пакет (bundle):</p>
<pre><code>$ git bundle create некий-файл HEAD</code></pre>
<p>Затем передает «пакет», <code>некий-файл</code>, другой команде любыми средствами, как то: электронная почта, флешка, <strong>xxd</strong>
 печать и последующее распознавание текста, надиктовка битов по 
телефону, дымовые сигналы и так далее. Получатель восстанавливает 
коммиты из пакета, введя</p>
<pre><code>$ git pull некий-файл</code></pre>
<p>Получатель может сделать это даже в пустом хранилище. Несмотря на свой небольшой размер, <code>некий-файл</code> содержит всё исходное хранилище Git.</p>
<p>В больших проектах для устранения излишков объема пакетируют только 
изменения, которых нет в других хранилищах. К примеру, пусть коммит 
«1b6d…» — последний общий для обеих групп:</p>
<pre><code>$ git bundle create некий-файл HEAD ^1b6d</code></pre>
<p>Если это делается часто, можно легко забыть, какой коммит был 
отправлен последним. Справка предлагает для решения этой проблемы 
использовать теги. А именно, после передачи пакета введите</p>
<pre><code>$ git tag -f последний-пакет HEAD</code></pre>
<p>и создавайте обновленные пакеты с помощью</p>
<pre><code>$ git bundle create новый-пакет HEAD ^последний-пакет</code></pre>
<h2 id="_патчи_общее_применение">Патчи: общее применение</h2>
<p>Патчи это тексты изменений, вполне понятные как человеку, так и 
компьютеру. Это делает их очень привлекательным форматом обмена. Патч 
можно послать разработчикам по электронной почте, независимо от того, 
какую систему управления версиями они используют. Вашим корреспондентам 
достаточно возможности читать электронную почту, чтобы увидеть ваши 
изменения. Точно так же, с Вашей стороны требуется лишь адрес 
электронной почты: нет нужды в настройке онлайн хранилища Git.</p>
<p>Вспомним из первой главы:</p>
<pre><code>$ git diff 1b6d</code></pre>
<p>выводит патч, который может быть вставлен в письмо для обсуждения. В Git хранилище введите</p>
<pre><code>$ git apply &lt; мой.patch</code></pre>
<p>для применения патча.</p>
<p>В более формальных случаях , когда нужно сохранить имя автора и 
подписи, создавайте соответствующие патчи с заданной точки, набрав</p>
<pre><code>$ git format-patch 1b6d</code></pre>
<p>Полученные файлы могут быть отправлены с помощью <strong>git-send-email</strong> или вручную. Вы также можете указать диапазон коммитов:</p>
<pre><code>$ git format-patch 1b6d..HEAD^^</code></pre>
<p>На принимающей стороне сохраните письмо в файл и введите:</p>
<pre><code>$ git am &lt; email.txt</code></pre>
<p>Это применит входящие исправления и создаст коммит, включающий имя автора и другую информацию.</p>
<p>С web-интерфейсом к электронной почте вам, возможно, потребуется 
нажать кнопку, чтобы посмотреть электронную почту в своем первоначальном
 виде перед сохранением патча в файл.</p>
<p>Для клиентов электронной почты, использующих mbox, есть небольшие 
отличия; но если вы используете один из них, то вы, по всей видимости, 
можете легко разобраться в этом без чтения описаний!</p>
<h2 id="_приносим_извинения_мы_переехали">Приносим извинения, мы переехали</h2>
<p>После клонирования хранилища команды <strong>git push</strong> или <strong>git pull</strong>
 автоматически отправляют и получают его по первоначальному адресу. 
Каким образом Git это делает? Секрет кроется в настройках, заданных при 
создании клона. Давайте взглянем:</p>
<pre><code>$ git config --list</code></pre>
<p>Опция <code>remote.origin.url</code> задает исходный адрес; origin — 
имя первоначального хранилища. Как и имя ветки master, это соглашение. 
Мы можем изменить или удалить это сокращённое имя, но как правило, нет 
причин для этого.</p>
<p>Если оригинальное хранилище переехало, можно обновить его адрес командой</p>
<pre><code>$ git config remote.origin.url git://новый.url/proj.git</code></pre>
<p>Опция <code>branch.master.merge</code> задает удаленную ветку по умолчанию для <strong>git pull</strong>.
 В ходе первоначального клонирования она устанавливается на текущую 
ветку исходного хранилища, так что даже если HEAD исходного хранилища 
впоследствии переместится на другую ветку, pull будет верно следовать 
изначальной ветке.</p>
<p>Этот параметр обращается только к хранилищу, которое мы изначально клонировали и которое записано в параметре <code>branch.master.remote</code>. При выполнении pull из других хранилищ мы должны указать нужную ветку:</p>
<pre><code>$ git pull git://пример.com/other.git master</code></pre>
<p>Это объясняет, почему некоторых из наших предыдущих примеров push и pull не имели аргументов.</p>
<h2 id="_удаленные_ветки">Удаленные ветки</h2>
<p>При клонировании хранилища вы также клонируете все его ветки. Вы 
можете не заметить этого, потому что Git скрывает их: вы должны 
запросить их явно. Это предотвращает противоречие между ветками в 
удаленном хранилище и вашими ветками, а также делает Git проще для 
начинающих.</p>
<p>Список удаленных веток можно посмотреть командой</p>
<pre><code>$ git branch -r</code></pre>
<p>Вы должны увидеть что-то вроде</p>
<pre><code>origin/HEAD
origin/master
origin/experimental</code></pre>
<p>Эти имена отвечают веткам и «голове» в удаленном хранилище; их можно 
использовать в обычных командах Git. Например, вы сделали много 
коммитов, и хотели бы сравнить текущее состояние с последней загруженной
 версией. Вы можете искать в журналах нужный SHA1 хеш, но гораздо легче 
набрать</p>
<pre><code>$ git diff origin/HEAD</code></pre>
<p>Также можно увидеть, для чего была создана ветка experimental:</p>
<pre><code>$ git log origin/experimental</code></pre>
<h2 id="_несколько_удаленных_хранилищ">Несколько удаленных хранилищ</h2>
<p>Предположим, что над нашим проектом работают еще два разработчика, и 
мы хотим следить за обоими. Мы можем наблюдать более чем за одним 
хранилищем одновременно, вот так:</p>
<pre><code>$ git remote add other git://пример.com/некое_хранилище.git
$ git pull other некая_ветка</code></pre>
<p>Сейчас мы сделали слияние с веткой из второго хранилища. Теперь у нас есть легкий доступ ко всем веткам во всех хранилищах:</p>
<pre><code> $ git diff origin/experimental^
other/некая_ветка~5</code></pre>
<p>Но что если мы просто хотим сравнить их изменения, не затрагивая свою
 работу? Иными словами, мы хотим изучить чужие ветки, не давая их 
изменениям вторгаться в наш рабочий каталог. Тогда вместо pull наберите</p>
<pre><code> $ git fetch # Перенести из origin, по
умолчанию.
 $ git fetch other # Перенести от
второго программиста.</code></pre>
<p>Так мы лишь переносим их историю. Хотя рабочий каталог остается 
нетронутыми, мы можем обратиться к любой ветке в любом хранилище 
команды, работающей с Git, так как теперь у нас есть локальная копия.</p>
<p>Держим в уме, что pull это просто <strong>fetch</strong>, а затем <strong>merge</strong>. Обычно мы используем <strong>pull</strong>, потому что мы хотим влить к себе последний коммит после получения чужой ветки. Описанная ситуация — примечательное исключение.</p>
<p>О том, как отключить удаленные хранилища, игнорировать отдельные ветки и многом другом смотрите в <strong>git help remote</strong>.</p>
<h2 id="_мои_настройки">Мои Настройки</h2>
<p>Я предпочитаю, чтобы люди, присоединяющиеся к моим проектам, 
создавали хранилища, из которых я смогу получать изменения с помощью 
pull. Некоторые хостинги Git позволяют создавать собственные форки 
проекта в одно касание.</p>
<p>После получения дерева из удаленного хранилища я запускаю команды Git
 для навигации и изучения изменений, в идеале хорошо организованных и 
описанных. Я делаю слияние со своими изменения и возможно вношу 
дальнейшие правки. Когда я доволен результатом, я заливаю изменения в 
главное хранилище.</p>
<p>Хотя со мной мало сотрудничают, я верю, что этот подход хорошо масштабируется. Смотрите <a href="http://torvalds-family.blogspot.com/2009/06/happiness-is-warm-scm.html">эту запись в блоге Линуса Торвальдса</a>.</p>
<p>Оставаться в мире Git несколько удобнее, чем использовать файлы 
патчей, так как это избавляет меня от преобразования их в коммиты Git. 
Кроме того, Git управляет деталями вроде сохранения имени автора и 
адреса электронной почты, а также даты и времени, и просит авторов 
описывать свои изменения.</p>
<h1 id="_гроссмейстерство_git">Гроссмейстерство Git</h1>
<p>Теперь вы уже должны уметь ориентироваться в страницах <strong>git help</strong>
 и понимать почти всё. Однако точный выбор команды, необходимой для 
решения конкретной проблемы, может быть утомительным. Возможно, я 
сберегу вам немного времени: ниже приведены рецепты, пригодившиеся мне в
 прошлом.</p>
<h2 id="_релизы_исходников">Релизы исходников</h2>
<p>В моих проектах Git управляет в точности теми файлами, которые я 
собираюсь архивировать и пускать в релиз. Чтобы создать тарбол с 
исходниками, я выполняю:</p>
<pre><code>$ git archive --format=tar --prefix=proj-1.2.3/ HEAD</code></pre>
<h2 id="_коммит_изменений">Коммит изменений</h2>
<p>В некоторых проектах может быть трудоемко оповещать Git о каждом 
добавлении, удалении и переименовании файла. Вместо этого вы можете 
выполнить команды</p>
<pre><code>$ git add .
$ git add -u</code></pre>
<p>Git просмотрит файлы в текущем каталоге и сам позаботится о деталях. Вместо второй команды add, выполните <strong>git commit -a</strong>, если вы собираетесь сразу сделать коммит. Смотрите <strong>git help ignore</strong>, чтобы узнать как указать файлы, которые должны игнорироваться.</p>
<p>Вы можете выполнить все это одним махом:</p>
<pre><code>$ git ls-files -d -m -o -z | xargs -0 git update-index --add --remove</code></pre>
<p>Опции <strong>-z</strong> и <strong>-0</strong> предотвращают 
неверную обработку файловых имен, содержащих специальные символы. 
Поскольку эта команда добавляет игнорируемые файлы, вы возможно захотите
 использовать опции -x или -X.</p>
<h2 id="_мой_коммит_слишком_велик">Мой коммит слишком велик</h2>
<p>Вы пренебрегали коммитами слишком долго? Яростно писали код и 
вспомнили об управлении исходниками только сейчас? Внесли ряд 
несвязанных изменений, потому что это ваш стиль?</p>
<p>Нет поводов для беспокойства. Выполните</p>
<pre><code>$ git add -p</code></pre>
<p>Для каждой сделанной вами правки Git покажет измененный участок кода и
 спросит, должно ли это изменение попасть в следующий коммит. Отвечайте 
«y» (да) или «n» (нет). У вас есть и другие варианты, например отложить 
выбор; введите «?» чтобы узнать больше.</p>
<p>Когда закончите, выполните</p>
<pre><code>$ git commit</code></pre>
<p>для внесения именно тех правок, что вы выбрали («буферизованных» изменений). Убедитесь, что вы не указали опцию <strong>-a</strong>, иначе Git закоммитит все правки.</p>
<p>Что делать, если вы изменили множество файлов во многих местах? 
Проверка каждого отдельного изменения становится удручающей рутиной. В 
этом случае используйте <strong>git add -i</strong>. Ее интерфейс не так
 прост, но более гибок. В несколько нажатий кнопок можно добавить или 
убрать из буфера несколько файлов одновременно, либо просмотреть и 
выбрать изменения лишь в отдельных файлах. Как вариант, запустите <strong>git commit --interactive</strong>, которая автоматически сделает коммит когда вы закончите.</p>
<h2 id="_индекс_буферная_зона_git">Индекс — буферная зона Git</h2>
<p>До сих пор мы избегали знаменитого «индекса» Git, но теперь мы должны
 рассмотреть его, для пояснения вышесказанного. Индекс это временный 
буфер. Git редко перемещает данные непосредственно между вашим проектом и
 его историей. Вместо этого Git сначала записывает данные в индекс, а уж
 затем копирует их из индекса по месту назначения.</p>
<p>Например, <strong>commit -a</strong> на самом деле двухэтапный 
процесс. Сначала слепок текущего состояния каждого из отслеживаемых 
файлов помещается в индекс. Затем слепок, находящийся в индексе, 
записывается в историю. Коммит без опции <strong>-a</strong> выполняет только второй шаг, и имеет смысл только после выполнения команд, изменяющих индекс, таких как <strong>git add</strong>.</p>
<p>Обычно мы можем не обращать внимания на индекс и делать вид, что 
взаимодействуем напрямую с историей. Но в данном случае мы хотим более 
тонкого контроля, поэтому управляем индексом. Мы помещаем слепок 
некоторых (но не всех) наших изменений в индекс, после чего окончательно
 записываем этот аккуратно сформированный слепок.</p>
<h2 id="_не_теряй_головы">Не теряй «головы»</h2>
<p>Тег HEAD (англ. «голова», прим. пер.) — как курсор, который обычно 
указывает на последний коммит, продвигаясь с каждым новым коммитом. 
Некоторые команды Git позволяют перемещать этот курсор. Например,</p>
<pre><code>$ git reset HEAD~3</code></pre>
<p>переместит HEAD на три коммита назад. Теперь все команды Git будут 
работать так, как будто вы не делали последних трех коммитов, хотя файлы
 останутся в текущем состоянии. В справке описано несколько способов 
использования этого приема.</p>
<p>Но как вернуться назад в будущее? Ведь предыдущие коммиты о нем ничего не знают.</p>
<p>Если у вас есть SHA1 изначальной «головы», то:</p>
<pre><code>$ git reset 1b6d</code></pre>
<p>Но допустим, вы его не записывали. Не беспокойтесь: для комнад такого
 рода Git сохраняет оригинальную «голову» как тег под названием 
ORIG_HEAD, и вы можете вернуться надежно и безопасно:</p>
<pre><code>$ git reset ORIG_HEAD</code></pre>
<h2 id="_охота_за_головами">Охота за «головами»</h2>
<p>Предположим ORIG_HEAD недостаточно. К примеру, вы только что 
осознали, что допустили громадную ошибку, и вам нужно вернуться к 
древнему коммиту в давно забытой ветке.</p>
<p>По умолчанию Git хранит коммиты не меньше двух недель, даже если вы 
приказали уничтожить содержащую их ветку. Проблема в нахождении 
соответствующего хеша. Вы можете просмотреть все значения хешей в 
.git/objects и методом проб и ошибок найти нужный. Но есть путь 
значительно легче.</p>
<p>Git записывает каждый подсчитанный им хеш коммита в .git/logs. В 
подкатлоге refs содержится полная история активности на всех ветках, а 
файл HEAD содержит каждое значение хеша, которое когда-либо принимал 
HEAD. Последнее можно использовать чтобы найти хеши коммитов на случайно
 обрубленных ветках.</p>
<p>Команда reflog предоставляет удобный интерфейс работы с этими журналами. Используйте</p>
<pre><code>$ git reflog</code></pre>
<p>Вместо копирования хешей из reflog, попробуйте</p>
<pre><code>$ git checkout "@{10 minutes ago}" # 10 минут назад, прим. пер.</code></pre>
<p>Или сделайте чекаут пятого с конца из посещенных коммитов с помощью</p>
<pre><code>$ git checkout "@{5}"</code></pre>
<p>Смотрите раздел «Specifying Revisions» в <strong>git help rev-parse</strong> для дополнительной информации.</p>
<p>Вы можете захотеть удлинить отсрочку для коммитов, обреченных на удаление. Например,</p>
<pre><code>$ git config gc.pruneexpire "30 days"</code></pre>
<p>означает, что удаляемые коммиты будут окончательно исчезать только по прошествии 30 дней и после запуска <strong>git gc</strong>.</p>
<p>Также вы можете захотеть отключить автоматический вызов <strong>git gc</strong>:</p>
<pre><code>$ git config gc.auto 0</code></pre>
<p>В этом случае коммиты будут удаляться только когда вы будете запускать <strong>git gc</strong> вручную.</p>
<h2 id="_git_как_основа">Git как основа</h2>
<p>Дизайн Git, в истинном духе UNIX, позволяет легко использовать его 
как низкоуровневый компонент других программ: графических и 
веб-интерфейсов; альтернативных интерфейсов командной строки; 
инструментов управления патчами; средств импорта или конвертации, и так 
далее. Многие команды Git на самом деле — скрипты, стоящие на плечах 
гигантов. Небольшой доработкой вы можете переделать Git на свой вкус.</p>
<p>Простейший трюк — использование алиасов Git для сокращения часто используемых команд:</p>
<pre><code>$ git config --global alias.co checkout
$ git config --global --get-regexp alias       # отображает текущие алиасы
alias.co checkout
$ git co foo # то-же, что и «git checkout foo»</code></pre>
<p>Другой пример: можно выводить текущую ветку в приглашении командной строки или заголовке окна терминала. Запуск</p>
<pre><code>$ git symbolic-ref HEAD</code></pre>
<p>выводит название текущей ветки. На практике вы скорее всего захотите убрать «refs/heads/» и сообщения об ошибках:</p>
<pre><code>$ git symbolic-ref HEAD 2&gt; /dev/null | cut -b 12-</code></pre>
<p>Подкаталог <code>contrib</code> это целая сокровищница инструментов, 
построенных на Git. Со временем некоторые из них могут становиться 
официальными командами. В Debian и Ubuntu этот каталог находится в <code>/usr/share/doc/git-core/contrib</code>.</p>
<p>Один популярный инструмент из этого каталога — <code>workdir/git-new-workdir</code>. Этот скрипт создает с помощью символических ссылок новый рабочий каталог, имеющий общую историю с оригинальным хранилищем:</p>
<pre><code>$ git-new-workdir существующее/хранилище новый/каталог</code></pre>
<p>Новый каталог и файлы в нем можно воспринимать как клон, с той 
разницей, что два дерева автоматически остаются синхронизированными 
ввиду общей истории. Нет необходимости в merge, push и pull.</p>
<h2 id="_рискованные_трюки">Рискованные трюки</h2>
<p>Нынешний Git делает случайное уничтожение данных очень сложным. Но 
если вы знаете, что делаете, вы можете обойти защиту для 
распространенных команд.</p>
<p><strong>Checkout</strong>: Наличие незакоммиченных изменений 
прерывает выполнение checkout. Чтобы перейти к нужному коммиту, даже 
уничтожив свои изменения, используйте «принуждающий» (force, прим. пер.)
 флаг <strong>-f</strong>:</p>
<pre><code>$ git checkout -f HEAD^</code></pre>
<p>С другой стороны, если вы укажете checkout конкретные пути, проверки 
на безопасность не будет: указанные файлы молча перезапишутся. Будьте 
осторожны при таком использовании checkout.</p>
<p><strong>Reset</strong>: сброс также прерывается при наличии незакоммиченных изменений. Чтобы заставить его сработать, запустите</p>
<pre><code>$ git reset --hard 1b6d</code></pre>
<p><strong>Branch</strong>: Удаление ветки прервётся, если оно привело бы к потере изменений. Для принудительного удаления введите</p>
<pre><code>$ git branch -D мертвая_ветка # вместо -d</code></pre>
<p>Аналогично, попытка перезаписи ветки путем перемещения будет 
прервана, если может привести к потере данных. Для принудительного 
перемещений ветки введите</p>
<pre><code>$ git branch -M источник цель # вместо -m</code></pre>
<p>В отличии от checkout и reset, эти две команды дают отсрочку в 
удалении данных. Изменения остаются в каталоге .git и могут быть 
возвращены восстановлением нужного хеша из .git/logs (смотрите выше 
раздел «Охота за „головами“»). По умолчанию они будут храниться по 
крайней мере две недели.</p>
<p><strong>Clean</strong>: Некоторые команды могут не сработать из 
опасений повредить неотслеживаемые файлы. Если вы уверены, что все 
неотслеживаемые файлы и каталоги не нужны, то безжалостно удаляйте их 
командой</p>
<pre><code>$ git clean -f -d</code></pre>
<p>В следующий раз эта досадная команда сработает!</p>
<h2 id="_предотвращаем_плохие_коммиты">Предотвращаем плохие коммиты</h2>
<p>Глупые ошибки загрязняют мои хранилища. Самое ужасное это проблема недостающих файлов, вызванная забытым <strong>git add</strong>.</p>
<p>Примеры менее серьезных проступков: завершающие пробелы и 
неразрешённые конфликты слияния. Несмотря на безвредность, я не хотел 
бы, чтобы это появлялось в публичных записях.</p>
<p>Если бы я только поставил защиту от дурака, используя <em>хук</em>, который бы предупреждал меня об этих проблемах:</p>
<pre><code>$ cd .git/hooks
$ cp pre-commit.sample pre-commit # В старых версиях Git: chmod +x pre-commit</code></pre>
<p>Теперь Git отменит коммит, если обнаружит лишние пробелы или неразрешенные конфликты.</p>
<p>Для этого руководства я в конце концов добавил следующее в начало хука <strong>pre-commit</strong>, чтобы защититься от своей рассеянности:</p>
<p>if git ls-files -o | grep <em>\.txt$</em>; then echo ПРЕРВАНО! Неотслеживаемые .txt файлы. exit 1 fi</p>
<p>Хуки поддерживаются несколькими различными операциями Git, смотрите <strong>git help hooks</strong>. Мы использовали пример хука <strong>post-update</strong> раньше, при обсуждении использования Git через http. Он запускался при каждом перемещении «головы». Пример скрипта <strong>post-update</strong> обновляет файлы, которые нужны Git для связи через не считающиеся с ним средства сообщения, такие как HTTP.</p>
<h1 id="_раскрываем_тайны">Раскрываем тайны</h1>
<p>Мы заглянем под капот и объясним, как Git творит свои чудеса. Я опущу
 излишние детали. За более детальными описаниями обратитесь к <a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html">руководству пользователя</a>.</p>
<h2 id="_невидимость">Невидимость</h2>
<p>Как Git может быть таким ненавязчивым? За исключением периодических 
коммитов и слияний, вы можете работать так, как будто и не подозреваете о
 каком-то управлении версиями. Так происходит до того момента, когда Git
 вам понадобится, и тогда вы с радостью увидите, что он наблюдал за вами
 все это время.</p>
<p>Другие системы управления версиями вынуждают вас постоянно бороться с
 загородками и бюрократией. Файлы могут быть доступны только для чтения,
 пока вы явно не укажете центральному серверу, какие файлы вы 
намереваетесь редактировать. С увеличением количества пользователей 
большинство базовых команд начинают выполняться всё медленнее. Неполадки
 с сетью или с центральным сервером полностью останавливают работу.</p>
<p>В противоположность этому, Git просто хранит историю проекта в 
подкаталоге .git вашего рабочего каталога. Это ваша личная копия 
истории, поэтому вы можете оставаться вне сети, пока не захотите 
взаимодействовать с остальными. У вас есть полный контроль над судьбой 
ваших файлов, поскольку Git в любое время может легко восстановить 
сохраненное состояние из .git.</p>
<h2 id="_целостность">Целостность</h2>
<p>Большинство людей ассоциируют криптографию с содержанием информации в
 секрете, но другой столь же важной задачей является содержание ее в 
сохранности. Правильное использование криптографических хеш-функций 
может предотвратить случайное или злонамеренное повреждение данных.</p>
<p>SHA1 хеш можно рассматривать как уникальный 160-битный идентификатор 
для каждой строки байт, с которой вы сталкиваетесь в вашей жизни. Даже 
больше того: для каждой строки байтов, которую любой человек когда-либо 
будет использовать в течение многих жизней.</p>
<p>Так как SHA1 хеш сам является последовательностью байтов, мы можем 
получить хеш строки байтов, содержащей другие хеши. Это простое 
наблюдение на удивление полезно: ищите «hash chains» (цепочки хешей). 
Позднее мы увидим, как Git использует их для эффективного обеспечения 
целостности данных.</p>
<p>Говоря кратко, Git хранит ваши данные в подкаталоге ".git/objects", 
где вместо нормальных имен файлов вы найдете только идентификаторы. 
Благодаря использованию идентификаторов в качестве имен файлов, а также 
некоторым хитростям с файлами блокировок и временны́ми метками, Git 
преобразует любую скромную файловую систему в эффективную и надежную 
базу данных.</p>
<h2 id="_интеллект">Интеллект</h2>
<p>Как Git узнаёт, что вы переименовали файл, даже если вы никогда не упоминали об этом явно? Конечно, вы можете запустить <strong>git mv</strong>; но это то же самое, что <strong>git rm</strong>, а затем <strong>git add</strong>.</p>
<p>Git эвристически находит файлы, которые были переименованы или 
скопированы между соседними версиями. На деле он может обнаружить, что 
участки кода были перемещены или скопированы между файлами! Хотя Git не 
может охватить все случаи, он всё же делает достойную работу, и эта 
функция постоянно улучшается. Если она не сработала, попробуйте опции, 
включающие более ресурсоемкое обнаружение копирования и подумайте об 
обновлении.</p>
<h2 id="_индексация">Индексация</h2>
<p>Для каждого отслеживаемого файла, Git записывает такую информацию, 
как размер, время создания и время последнего изменения, в файле, 
известном как «индекс». Чтобы определить, был ли файл изменен, Git 
сравнивает его текущие характеристики с сохраненными в индексе. Если они
 совпадают, то Git не станет перечитывать файл заново.</p>
<p>Поскольку считывание этой информации значительно быстрее, чем чтение 
всего файла, то если вы редактировали лишь несколько файлов, Git может 
обновить свой индекс почти мгновенно.</p>
<p>Мы отмечали ранее, что индекс это буферная зона. Почему набор свойств
 файлов выступает таким буфером? Потому что команда add помещает файлы в
 базу данных Git и в соответствии с этим обновляет эти свойства; тогда 
как команда commit без опций создает коммит, основанный только на этих 
свойствах и файлах, которые уже в базе данных.</p>
<h2 id="_происхождение_git">Происхождение Git</h2>
<p>Это <a href="http://lkml.org/lkml/2005/4/6/121">сообщение в почтовой рассылке ядра Linux</a>
 описывает последовательность событий, которые привели к появлению Git. 
Весь этот тред — привлекательный археологический раскоп для историков 
Git.</p>
<h2 id="_база_данных_объектов">База данных объектов</h2>
<p>Каждая версия ваших данных хранится в «базе данных объектов», живущей
 в подкаталоге .git/objects. Другие «жители» .git/ содержат вторичные 
данные: индекс, имена веток, теги, параметры настройки, журналы, 
нынешнее расположение «головного» коммита и так далее. База объектов 
проста и элегантна, и в ней источник силы Git.</p>
<p>Каждый файл внутри .git/objects это «объект». Нас интересуют три типа
 объектов: объекты «блобов», объекты деревьев и объекты коммитов.</p>
<h2 id="_блобы">Блобы</h2>
<p>Для начала один фокус. Выберите имя файла — любое имя файла. В пустом каталоге:</p>
<pre><code>$ echo sweet &gt; ВАШЕ_ИМЯ_ФАЙЛА
$ git init
$ git add .
$ find .git/objects -type f</code></pre>
<p>Вы увидите <code>.git/objects/aa/823728ea7d592acc69b36875a482cdf3fd5c8d</code>.</p>
<p>Откуда я знаю это, не зная имени файла? Это потому, что SHA1 хеш строки</p>
<pre><code>«blob» SP «6» NUL «sweet» LF</code></pre>
<p>равен aa823728ea7d592acc69b36875a482cdf3fd5c8d, где SP это пробел, 
NUL — нулевой байт и LF — перевод строки. Вы можете проверить это, 
набрав</p>
<pre><code>$ printf "blob 6\000sweet\n" | sha1sum</code></pre>
<p>Git использует «адресацию по содержимому»: файлы хранятся в 
соответствии не с именами, а с хешами содержимого, — в файле, который мы
 называем «блоб-объектом». Хеш можно понимать как уникальный 
идентификатор содержимого файла, что означает обращение к файлам по их 
содержимому. Начальный «blob 6» — лишь заголовок, состоящий из типа 
объекта и его длины в байтах и упрощающий внутренний учет.</p>
<p>Таким образом, я могу легко предсказать, что вы увидите. Имя файла не
 имеет значения: для создания блоб-объекта используется только его 
содержимое.</p>
<p>Вам может быть интересно, что происходит с одинаковыми файлами. 
Попробуйте добавить копии своего файла с какими угодно именами. 
Содержание <code>.git/objects</code> останется тем же независимо от того, сколько копий вы добавите. Git хранит данные лишь единожды.</p>
<p>Кстати, файлы в каталоге <code>.git/objects</code> сжимаются с помощью zlib поэтому вы не сможете просмотреть их напрямую. Пропустите их через фильтр <a href="http://www.zlib.net/zpipe.c">zpipe -d</a>, или введите</p>
<pre><code>$ git cat-file -p aa823728ea7d592acc69b36875a482cdf3fd5c8d</code></pre>
<p>что выведет указанный объект в читаемом виде.</p>
<h2 id="_деревья">Деревья</h2>
<p>Но где же имена файлов? Они должны храниться на каком-то уровне. Git обращается за именами во время коммита:</p>
<pre><code>$ git commit  # Введите какое-нибудь описание
$ find .git/objects -type f</code></pre>
<p>Теперь вы должны увидеть три объекта. На этот раз я не могу сказать 
вам, что из себя представляют два новых файла, так как это частично 
зависит от выбранного вами имени файла. Далее будем предполагать, что вы
 назвали его «rose». Если это не так, то вы можете переписать историю, 
чтобы она выглядела как будто вы это сделали:</p>
<pre><code>$ git filter-branch --tree-filter 'mv ВАШЕ_ИМЯ_ФАЙЛА rose'
$ find .git/objects -type f</code></pre>
<p>Теперь вы должны увидеть файл <code>.git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9</code>, так как это SHA1 хеш его содержимого:</p>
<pre><code>«tree» SP «32» NUL «100644 rose» NUL 0xaa823728ea7d592acc69b36875a482cdf3fd5c8d</code></pre>
<p>Проверьте, что этот файл действительно содержит указанную строку, набрав</p>
<pre><code>$ echo 05b217bb859794d08bb9e4f7f04cbda4b207fbe9 | git cat-file --batch</code></pre>
<p>С zpipe легко проверить хеш:</p>
<pre><code>$ zpipe -d &lt; .git/objects/05/b217bb859794d08bb9e4f7f04cbda4b207fbe9 | sha1sum</code></pre>
<p>Проверка хеша с помощью cat-file сложнее, поскольку ее вывод содержит не только «сырой» распакованный файл объекта.</p>
<p>Этот файл — объект «дерево» (tree, прим. пер.): список цепочек, 
состоящих из типа, имени файла и его хеша. В нашем примере: тип файла — 
100644, что означает, что «rose» это обычный файл; а хеш — блоб-объект, в
 котором находится содержимое «rose». Другие возможные типы файлов: 
исполняемые файлы, символические ссылки или каталоги. В последнем 
случае, хеш указывает на объект «дерево».</p>
<p>Если вы запускали filter-branch, у вас есть старые объекты которые 
вам больше не нужны. Хотя по окончании срока хранения они будут 
выброшены автоматически, мы удалим их сейчас, чтобы было легче следить 
за нашим игрушечным примером:</p>
<pre><code>$ rm -r .git/refs/original
$ git reflog expire --expire=now --all
$ git prune</code></pre>
<p>Для реальных проектов обычно лучше избегать таких команд, поскольку 
вы уничтожаете резервные копии. Если вы хотите иметь чистое хранилище, 
то обычно лучше сделать свежий клон. Кроме того, будьте осторожны при 
непосредственном вмешательстве в каталог <code>.git</code>: что если 
другая команда Git работает в это же время, или внезапно произойдет 
отключение питания? Вообще говоря, ссылки нужно удалять с помощью <strong>git update-ref -d</strong>, хотя обычно ручное удаление <code>refs/original</code> безопасно.</p>
<h2 id="_коммиты">Коммиты</h2>
<p>Мы рассмотрели два из трех объектов. Третий объект — «коммит» 
(commit). Его содержимое зависит от описания коммита, как и от даты и 
времени его создания. Для соответстия тому, что мы имеем, мы должны 
немного «подкрутить» Git:</p>
<pre><code>$ git commit --amend -m Shakespeare  # Изменим описание коммита.
$ git filter-branch --env-filter 'export
    GIT_AUTHOR_DATE="Fri 13 Feb 2009 15:31:30 -0800"
    GIT_AUTHOR_NAME="Alice"
    GIT_AUTHOR_EMAIL="alice@example.com"
    GIT_COMMITTER_DATE="Fri, 13 Feb 2009 15:31:30 -0800"
    GIT_COMMITTER_NAME="Bob"
    GIT_COMMITTER_EMAIL="bob@example.com"'  # Подделаем временные метки и авторов.
$ find .git/objects -type f</code></pre>
<p>Теперь вы должны увидеть <code>.git/objects/49/993fe130c4b3bf24857a15d7969c396b7bc187</code> который является SHA1 хешем его содержимого:</p>
<pre><code>«commit 158» NUL
«tree 05b217bb859794d08bb9e4f7f04cbda4b207fbe9» LF
«author Alice &lt;alice@example.com&gt; 1234567890 -0800» LF
«committer Bob &lt;bob@example.com&gt; 1234567890 -0800» LF
LF
«Shakespeare» LF</code></pre>
<p>Как и раньше, вы сами можете запустить zpipe или cat-file, чтобы увидить это.</p>
<p>Это первый коммит, поэтому здесь нет родительских коммитов, но 
последующие коммиты всегда будет содержать хотя бы одну строку, 
идентифицирующую родительский коммит.</p>
<h2 id="_неотличимо_от_волшебства">Неотличимо от волшебства</h2>
<p>Секреты Git выглядят слишком простыми. Похоже, что вы могли бы 
объединить несколько shell-скриптов и добавить немного кода на C, чтобы 
сделать всё это в считанные часы: смесь базовых операций с файлами и 
SHA1-хеширования, приправленная блокировочными файлами и fsync для 
надеждности. По сути, это точное описание ранних версий Git. Тем не 
менее, помимо гениальных трюков с упаковкой для экономии места и с 
индексацией для экономии времени, мы теперь знаем, как ловко Git 
преображает файловую систему в базу данных, идеально подходящую для 
управления версиями.</p>
<p>Например, если какой-либо файл в базе данных объектов поврежден из-за
 ошибки диска, то его хеш теперь не совпадет, что привлечет наше 
внимание к проблеме. С помощью хеширования хешей других объектов, мы 
поддерживаем целостность на всех уровнях. Коммиты атомарны, так что в 
них никогда нельзя записать лишь часть изменений: мы можем вычислить хеш
 коммита и сохранить его в базу данных только сохранив все 
соответствующие деревья, блобы и родительские коммиты. База данных 
объектов нечувствительна к непредвиденным прерываниям работы, таких как 
перебои с питанием.</p>
<p>Мы наносим поражение даже самым хитрым противникам. Предположим, 
кто-то пытается тайно изменить содержимое файла в древней версии 
проекта. Чтобы база объектов выглядела неповрежденной, он также должен 
изменить хеш соответствующего блоб-объекта, поскольку это теперь другая 
последовательность байтов. Это означает, что нужно поменять хеши всех 
объектов деревьев, ссылающихся на этот файл; что в свою очередь изменит 
хеши всех объектов коммитов с участием таких деревьев; а также и хеши 
всех потомков этих коммитов. Вследствие этого хеш официальной головной 
ревизии будет отличаться от аналогичного хеша в этом испорченном 
хранилище. По цепочке несовпадающих хешей мы можем точно вычислить 
искаженный файл, как и коммит, где он изначально был поврежден.</p>
<p>Одним словом, невозможно подделать хранилище Git, оставив невредимыми двадцать байт, отвечающие последнему коммиту.</p>
<p>Как насчет известных характерных особенностей Git? Ветвление? 
Слияние? Теги? Очевидные подробности. Текущая «голова» хранится в файле <code>.git/HEAD</code>,
 содержащем хеш объекта коммита. Хеш обновляется во время коммита, а 
также при выполнении многих других команд. С ветками всё аналогично: это
 файлы в <code>.git/refs/heads</code>. То же и тегами: они живут в <code>.git/refs/tags</code>, но их обновляет другой набор команд.</p>
<h1 id="_недостатки_git">Недостатки Git</h1>
<p>Есть некоторые проблемы Git, которые я спрятал под сукно. Некоторые 
из них можно легко решить с помощью скриптов и хуков, некоторые требуют 
реорганизации или пересмотра проекта, а несколько оставшихся 
неприятностей придется потерпеть. А еще лучше — взяться за них и решить!</p>
<h2 id="_слабости_sha1">Слабости SHA1</h2>
<p>Со временем криптографы обнаруживают всё больше и больше слабостей в 
SHA1. Уже сейчас обнаружение коллизий хешей осуществимо для хорошо 
финансируемой организации. Спустя годы, возможно, даже типичный ПК будет
 иметь достаточную вычислительную мощность, чтобы незаметно испортить 
хранилище Git.</p>
<p>Надеюсь, Git перейдет на лучшую хеш-функцию прежде чем дальнейшие исследования уничтожат SHA1.</p>
<h2 id="_microsoft_windows">Microsoft Windows</h2>
<p>Git на Microsoft Windows может быть громоздким:</p>
<ul>
<li><p><a href="http://cygwin.com/">Cygwin</a>, Linux-подобная среда для Windows, содержащая <a href="http://cygwin.com/packages/git/">порт Git на Windows</a>.</p></li>
<li><p><a href="https://gitforwindows.org/">Git для Windows</a>, вариант, требующий минимальной рантайм поддержки, хотя некоторые комманды нуждаются в доработке.</p></li>
</ul>
<h2 id="_несвязанные_файлы">Несвязанные файлы</h2>
<p>Если ваш проект очень велик и содержит много несвязанных файлов, 
которые постоянно изменяются, Git может оказаться в невыгодном положении
 по сравнению с другими системами, поскольку отдельные файлы не 
отслеживаются. Git отслеживает изменения всего проекта, что обычно 
бывает выгодным.</p>
<p>Решение — разбить проект на части, каждая из которых состоит из взаимосвязанных файлов. Используйте <strong>git submodule</strong> если вы все же хотите держать все в одном хранилище.</p>
<h2 id="_кто_и_что_редактировал">Кто и что редактировал ?</h2>
<p>Некоторые системы управления версиями вынуждают вас явным образом 
пометить файл перед редактированием. Хотя такой подход особенно 
раздражает, когда подразумевает работу с центральным сервером, однако он
 имеет два преимущества:</p>
<ol type="1">
<li><p>Diff'ы быстры, так как нужно проверить только отмеченные файлы.</p></li>
<li><p>Можно обнаружить, кто еще работает с этим файлом, спросив центральный сервер, кто отметил его для редактирования.</p></li>
</ol>
<p>С помощью соответствующих скриптов, вы можете добиться того же с Git.
 Это требует сотрудничества со стороны другого программиста, который 
должен запускать определенный скрипт при редактировании файла.</p>
<h2 id="_история_файла">История файла</h2>
<p>Поскольку Git записывает изменения всего проекта, воссоздание истории
 единичного файла требует больше работы, чем в системах управления 
версиями, следящими за отдельными файлами.</p>
<p>Потери как правило незначительны, и это неплохая цена за то, что 
другие операции невероятно эффективны. Например, git checkout быстрее, 
чем cp -a, а дельта всего проекта сжимается лучше, чем коллекция 
по-файловых дельт.</p>
<h2 id="_начальное_клонирование">Начальное Клонирование</h2>
<p>Создание клона хранилища дороже обычного чекаута в других системах управления версиями при длинной истории.</p>
<p>Первоначальная цена окупается в долгосрочной перспективе, так как 
большинство последующих операций будут быстрыми и автономными. Однако в 
некоторых ситуациях может быть предпочтительным создание мелких клонов с
 опцией --depth. Это намного быстрее, но у полученного клона будет 
урезанная функциональность.</p>
<h2 id="_изменчивые_проекты">Изменчивые Проекты</h2>
<p>Git был написан, чтобы быть быстрым при относительно небольших 
изменениях. Люди вносят незначительные правки от версии к версии. 
Однострочное исправление ошибки здесь, новая функция там, исправленные 
комментарии и тому подобное. Но если ваши файлы радикально различаются в
 соседних ревизиях, то с каждым коммитом ваша история неизбежно 
увеличится на размер всего проекта.</p>
<p>Никакая система управления версиями ничего не может с этим сделать, 
но пользователи Git страдают больше, поскольку обычно истории 
клонируются.</p>
<p>Причины, по которым эти изменения столь велики, нужно изучить. 
Возможно, надо изменить форматы файлов. Небольшие правки должны 
приводить к небольшим изменений не более чем в нескольких файлах.</p>
<p>Возможно, вам была нужна база данных или система резервного/архивного
 копирования, а не система управления версиями. Например, управление 
версиями может быть плохо приспособлено для обращения с фотографиями 
периодически получаемыми с веб-камеры.</p>
<p>Если файлы действительно должны постоянно изменяться и при этом 
версироваться, может иметь смысл использовать Git централизованным 
образом. Можно создавать мелкие клоны, с небольшой историей или без 
истории вообще. Конечно, многие инструменты Git будут недоступны, и 
исправления придется представлять в виде патчей. Возможно, это и хорошо,
 так как неясно, зачем кому-либо понадобится история крайне нестабильных
 файлов.</p>
<p>Другой пример — это проект, зависимый от прошивки, принимающей форму 
огромного двоичного файла. Ее история неинтересна пользователям, а 
обновления плохо сжимаются, потому ревизии прошивки будут неоправдано 
раздувать размер хранилища.</p>
<p>В этом случае исходный код стоит держать в хранилище Git, а бинарные 
файлы — отдельно. Для упрощения жизни можно распространять скрипт, 
использующий Git для клонирования кода и rsync или мелкий клон Git для 
прошивки.</p>
<h2 id="_глобальный_счетчик">Глобальный счетчик</h2>
<p>Некоторые централизованные системы управления версиями содержат 
натуральное число, увеличивающееся при поступлении нового коммита. Git 
идентифицирует изменения по их хешам, что лучше во многих 
обстоятельствах.</p>
<p>Но некоторым людям нравятся эти целые числа повсюду. К счастью, легко
 написать такой скрипт, чтобы при каждом обновлении центральное 
хранилище Git увеличивало целое число, возможно, в теге, и связывало его
 с хешем последнего коммита.</p>
<p>Каждый клон может поддерживать такой счетчик, но это, видимо, будет 
бесполезным, поскольку только центральное хранилище и его счетчик имеет 
значение для всех.</p>
<h2 id="_пустые_подкаталоги">Пустые подкаталоги</h2>
<p>Пустые подкаталоги не могут отслеживаться. Создавайте подставные файлы, чтобы обойти эту проблему.</p>
<p>В этом виноват не дизайн Git, а его текущая реализация. Если повезет и
 пользователи Git будут поднимать больше шума вокруг этой функции, 
возможно она будет реализована.</p>
<h2 id="_первоначальный_коммит">Первоначальный коммит</h2>
<p>Шаблонный компьютерщик считает с 0, а не с 1. К сожалению, в 
отношении коммитов Git не придерживается этого соглашения. Многие 
команды недружелюбны до первоначального коммита. Кроме того, некоторые 
частные случаи требуют специальной обработки, к примеру rebase ветки с 
другим начальным коммитом.</p>
<p>Git'у было бы выгодно определить нулевой коммит: при создании 
хранилища HEAD был бы установлен в строку, состоящую из 20 нулевых 
байтов. Этот специальный коммит представлял бы собой пустое дерево, без 
родителей, которое предшествует каждому хранилищу Git.</p>
<p>Тогда запуск <strong>git log</strong>, например, показывал бы 
пользователю, что коммиты еще не были сделаны, вместо того чтобы 
завершаться с фатальной ошибкой. Аналогично для других инструментов.</p>
<p>Каждый первоначальный коммит — неявный потомок этого нулевого коммита.</p>
<p>Однако здесь, к сожалению, есть некоторые проблемные случаи. Если 
несколько ветвей с различными начальными коммитами сливаются, то rebase 
результата требует значительного ручного вмешательства.</p>
<h2 id="_причуды_интерфейса">Причуды интерфейса</h2>
<p>Для коммитов А и Б значения выражений «А..Б» и «А…Б» зависят от того,
 ожидает ли команда указания двух конечных точек или промежутка. 
Смотрите <strong>git help diff</strong> и <strong>git help rev-parse</strong>.</p>
<h1 id="_перевод_этого_руководства">Перевод этого руководства</h1>
<p>Я советую следующий способ для перевода этого руководства, чтобы мои 
скрипты могли быстро создавать HTML и PDF версии, а все переводы 
находились в одном хранилище.</p>
<p>Клонируйте исходные тексты, затем создайте каталог, отвечающий тегу IETF целевого языка: смотрите <a href="http://www.w3.org/International/articles/language-tags/Overview.en.php">статью W3C по интернационализации</a>. К примеру, английский язык это «en», а японский — «ja». Скопируйте в каталог файлы <code>txt</code> из каталога «en» и переведите их.</p>
<p>К примеру, для перевода руководства на <a href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B8%D0%BD%D0%B3%D0%BE%D0%BD%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">клингонский язык</a>, вы можете набрать:</p>
<pre><code>$ git clone git://repo.or.cz/gitmagic.git
$ cd gitmagic
$ mkdir tlh # «tlh» — языковой код IETF клингонского языка.
$ cd tlh
$ cp ../en/intro.txt .
$ edit intro.txt  # Переведите файл.</code></pre>
<p>и так с каждым файлом.</p>
<p>Отредактируйте Makefile и добавьте код языка в переменную 
TRANSLATIONS. Теперь вы сможете просматривать вашу работу по ходу дела:</p>
<pre><code>$ make tlh
$ firefox book.html</code></pre>
<p>Почаще делайте коммиты, а когда ваш перевод будет готов, сообщите мне
 об этом. На GitHub есть веб-интерфейс, облегчающий описанные действия: 
сделайте форк проекта «gitmagic», залейте ваши изменения и попросите 
меня сделать слияние.</p>


</body></html>